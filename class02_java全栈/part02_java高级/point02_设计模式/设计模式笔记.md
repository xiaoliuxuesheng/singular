# 前言

## :anchor: 设计模式的分类

### 1. 创建型模式

- [x] 工厂方法模式
- [x] 抽象工厂模式
- [x] 单例模式
- [ ] 建造者模式
- [x] 原型模式

### 2. 结构型模式

- [ ] 配器模式
- [ ] 装饰者模式
- [ ] 代理模式
- [ ] 外观模式
- [ ] 桥接模式
- [ ] 组合模式
- [ ] 享元模式

### 3. 行为型模式

- [ ] 策略模式
- [ ] 模板方法模式
- [ ] 观察者模式
- [ ] 迭代子模式
- [ ] 责任链模式
- [ ] 命令模式
- [ ] 备忘录模式
- [ ] 状态模式
- [ ] 访问者模式
- [ ] 中介者模式
- [ ] 解释器模式

### 4. 其他

- [ ] 并发型模式
- [ ] 线程池模式

## :anchor: Java中类之间的关系

### 1. 依赖

- **定义** :  依赖是单向关系, 表示一个类依赖于另一个类的定义，其中一个类的变化将影响另外一个类
- **表现形式** : 局部变量，方法参数，静态方法调用等

### 2. 关联

- **定义** : 关联可以是单向或者双向关系, 表示一个类拥有另一个类, 
- **表现形式** : 通常表现为全局变量 (类属性)

### 3. 聚合

- **定义** : 聚合是单向关联的表现, 关联的两个对象通常是平等的,聚合则**一般不平等，有一种整体和局部的感觉**

### 4. 组合

- **定义 : ** 单向，是一种强依赖的特殊聚合关系
- **表现形式 : ** 各个类生命周期相同，如果整体不存在了，部分也将消亡

### 5. 继承

- **extend** 或 **implement** : 类继承抽象类，类继承父类都属于这种关系

## :anchor: 设计模式的六大原则

### ★ 总原则－开闭原则

- 对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级

### 1. 单一职责原则

> 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。

### 2 里氏替换原则

> 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

> 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

### 3. 依赖倒转原则

> 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

### 4. 接口隔离原则

> 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

### 5. 迪米特法则（最少知道原则）

> 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

> 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

### 6. 合成复用原则

> 尽量首先使用合成/聚合的方式，而不是使用继承。

# 第一章 单例模式

## 1.1 作用

- 指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

## 1.2 创建

# 第二章 工厂模式

## 2.1 作用

- **首先**，工厂模式是为了解耦：把对象的创建和使用的过程分开
- **其次**，工厂模式可以降低代码重复。如果创建对象B的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码
- **最后**，因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。

## 2.2 创建

### ★ - 简单工厂

:blue_book: 工厂的**静态方法** 或 **实例方法**

```java
public class Factory {
    
    public [static] Demo01Obj createDemo01(){
        return new Demo01Obj();
    }

    public [static] Demo02Obj createDemo02(){
        return new Demo02Obj();
    }

	... ...
}
```

:blue_book: **静态** 或 **实例** 的工厂方法 

```java
public class Factory {
    
    public [static] Object createObj(String objType){
        if ("demo01".equals(objType)) {
            return new Demo01Obj();
        } else if ("demo02".equals(objType)) {
            return new Demo02Obj();
        }
        ... ...
        return null;
    }
}
```

:blue_book: 反射 加 泛型设计工厂方法

```java
public class Factory {
    public static <T> T createObj(Class<T> objType)throws Exception{
        return objType.newInstance();
    }
}
```

### ★ - 工厂方法模式

- **实现原理**

    - 工厂类只需要定义抽象方法作为创建对象的规范, 创建对象的具体实现由子类实现
    - 每个对象都对应有一个工厂类, 每次创建对象只需要使用对象对应的工厂类即可创建.
    - 可以把具有相同创建方式而创建出来的对象成为一个**产品族**(区别于抽象工厂)

- **Java**

    - **首先制定工厂类的规范** : 所有对象的创建方式

        ```java
        public interface FactoryInterface {
            Object createObj();
        }
        ```

    - **其次为每个产品创建其对应的工厂类**

        ```java
        public class FactoryDemo02 implements FactoryInterface {
            public Object createObj() {
                return new Demo02Obj();
            }
        }
        ```

    - 创建对象

        ```java
        Demo02Obj obj2 = (Demo02Obj) new FactoryDemo02().createObj();
        ```

### ★ - 抽象工厂模式

- **实现原理**

    - 抽象工厂用于创建产品族, 当产品只有一个对象时候, 抽象工厂模式也是工厂方法模式(抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类)
    - 当需要对具有多个产品族的对象进行创建时候, 可以使用抽象工厂, 可以做到对产品族的产品进行扩展

- **Java**

    - **首先会存在多个产品族** : 此时每个产品族需要制定接口规范

        ```java
        public interface ProductOne {
        	// 产品族1的规范
        }
        
        public interface ProductTwo {
        	// 产品族2的规范
        }
        ```

    - 每个产品规范下可能有多个产品对象

    - 使用工厂方法模式给每个产品对象创建一个工厂类

    - **其次需要定义抽象工厂生产多个产品族的产品**

        ```java
        public interface AbstractFactory {
        
            ProductOne createOne();
        
            ProductTwo createTwo();
            
        }
        ```

    - 制定抽象工厂的客户端, 创建出每个产品族对应的产品

        ```java
        public class AbstractFactoryClient implements AbstractFactory {
        
            @Override
            public ProductOne createOne() {
                return new ProductOneFactory1().createModelOne();
            }
        
            @Override
            public ProductTwo createTwo() {
                return new ProductTwoFactory1().createModelTwo();
            }
            
        }
        ```

    - 调用者只需要执行抽象工厂的实现类, 就可以创建出对应的产品族对象了

- **特点**
  
    - 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改

# 第三章 建造者模式

## 3.1 作用

- 软件开发时候需要创建一个复杂对象, 这个复杂对象通常有多个子部件按照一定的步骤聚合而成(各个部件可以灵活选择，但其创建步骤都大同小异。
- 将一个复杂对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示
- 在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

## 3.2 创建

- **实现原理**
- 

# 第四章 原型模式

## 4.1 作用

- 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象
- 有一个对象，在某一个时刻该对象中已经包含了一些有效值，此时可能会需要一个和该对象完全相同的新对象，并且此后对新对象的任何改动都不会影响到原来对象中的值。

## 4.2 创建

- **实现原理**

    - 原型模式的核心是一个clone方法,通过该方法进行对象的拷贝,Java提供了一个Cloneable接口来标示这个对象是可拷贝的, 这个接口只是一个标记作用,在JVM中具有这个标记的对象才有可能被拷贝。

- **Java**

    ```java
    public class PrototypeObject implements Cloneable {
    	
        // 类成员
    
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }
    ```

    :anchor: **浅拷贝 :** Java的clone方法实现的是浅复制，对基本类型的复制。但对非基本类型的变量，复制的是对象的引用

    :anchor: **深拷贝** : 对非基本类型的变量, 在实现克隆方式时候对其进行克隆

- **特点**

    - 性能优良 : 是在内存二进制流的拷贝
    - 逃避构造函数的约束 : 接在内存中拷贝,构造函数是不会执行的

# 第五章 适配器模式

## 5.1 作用

- 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

## 5.2 创建

### ★ - 类适配器模式

- **实现原理**
  
- 类的适配器模式把适配的类的API转换成为目标类的API
  
- **Java**
  
    