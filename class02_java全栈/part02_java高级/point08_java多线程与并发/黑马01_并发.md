# java并发包

1. tools：
2. locks：锁
3. collections：集合
4. executor：执行器
5. aotmic：原子包

# 多核CPU缓存架构

- 主内存 -> 一级缓存 -> 二级缓存 -三级缓存 -> CPU寄存器

# volatile

- Java多线程内存模型是类似CPU缓存模型的，是基于CPU缓存模型建立的，Java内存模型是在JVM虚拟机中屏蔽的底层的不同机器的区别：java线程 读取 工作内存 保存 主内存共享变量 -》 主内存保存着共享变量
- 线程操作共享变量，首先会读取主内存中共享变量的副本保存到工作内存中的，而java线程操作的是工作内存中的变量
- JMM数据原子操作
  - read：读取：从主内存读取数据
  - load：载入：将主内存读取到的数据写入工作内存
  - usr：使用：从工作内存读取数据来计算
  - assign：赋值：将计算好的值重新复制到工作内存中
  - store：存储：将工作内存数据写入到主内存
  - write：将store过去的变量赋值给主内存的变量
  - lock：锁定：将主内存变量加锁，标识为线程独占状态
  - unlock：解锁：将主内存变量解锁，解锁后其他线程可以锁定改变量
- 缓存一致性协议：MESI：多个CPU从主内存读取同一个数据到各自的高速缓存，当其中一个CPU修改了缓存内的数据，改数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知到数据变化从而将自己缓存里的数据失效，
- 缓存加锁：缓存锁的核心机制是基于缓存一致性协议来实现的，一个处理器的的缓存回写到内存会导致其他处理器的缓存失效
- volatile底层原理：通过汇编的lock前缀指令，锁定这块区域内存的缓存（缓存行锁定）并写回到主存：
  - lock会将当前处理器缓存行的数据立即写回到系统内存；
  - 这个写回操作会使其他CPU里缓存改变量的数据无效
  - 立即写回系统内存，提供内存屏障功能，使lock前后的操作不能进行指令重排序
- 并发三大特性：可见性、有序性、原子性；volatile可以保证可见性和有序性，但是不能保证原子性
- 指令重拍：在不影响单线程程序执行结果的前提下，计算机为了更大限度的发挥机器性能，会对机器指令重排序优化：重排序原则：as-if-serial和happens-before
  - as-if-serial：不管怎么重排序，在单线程的执行结果不能改变
  - happens-before：不同的规则都不可以重排序
- 内存屏障：

# synchronized

# 线程

- 线程
  - 基础
  - 同步
  - 互斥
- JUC包：是java并发编程的核心
  - 锁实现的：AQS（是JUC包的核心）

- AQS：抽象队列同步器
  - 抢锁
  - 释放锁
  - 入队
  - 出队
  - 阻塞
  - 唤醒