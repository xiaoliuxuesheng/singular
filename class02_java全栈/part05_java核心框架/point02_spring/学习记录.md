# 001_Spring简介

- 框架的概念
- Spring
    - 是容器框架 - ioc 和 aop
    - 特点

# 002_Spring官网

- Spring技术栈
- Apache开源项目

# 003_Spring模块

- test
- core
- tx
- web
- aop

# 004_sts工具 - 005_Eclipse插件

# 006_IOC 和 aop

- ioc - di概念和作用
- aop概念和作用

# 007_Helloworld

- 向容器中注入对象

# 008_从容器中获取bean

- 获取IOC容器对象
- 从容器中获取组件
    - 组件创建的时机:在容器初始化时候
    - 容器中没有组件会报错
    - 
    - property标签是setter方法属性赋值

# 009_Helloworld总结

- classpath:类路径 - 源码包下
- ApplicationContext接口的实现类

# 010_根据类型从容器获取对象

- 根据类型找 : 找到多个组件也会报错
- 根据类型和id找 : 准确的找到组件对应的bean

# 011_构造器注入值 - 012

- 构造器参数标签

    - name - value
    - value
    - index - value

    - index - type - value

# 013_通过p名称空间赋值

- spring配置文件名称空间 : 防止标签重名
    - 引入p名称空间
- p名称空间的使用 : p:属性

# 014_为各种属性赋值 - null

- <property>的子标签<null> 标签表示null值

# 015_为各种属性赋值 - ref引用外部bean

- <property>的属性 ref = 外部bean

# 016_为各种属性赋值 - 定义内部bean

- property的子标签<bean> 表示内部bean
    - 内部bean不能被spring容器管理

# 017_为各种属性赋值 - list赋值

- <property>的<list> : list内部可以添加其他值或对象 或引用

# 018_为各种属性赋值 - map赋值

- <property>的<map> 的 <entry> 的key属性 和value属性

# 019_为各种属性赋值 - properties赋值

- <property>的<props>内部<prop key> value

# 020_为各种属性赋值 - util名称空间

- 添加util名称空间
- 使用util名称空间创建集合类型
    - list
    - map
    - set

# 021_级联属性赋值

- 级联属性的了解
- 级联属性赋值 : 使用点语法 : 属性.属性 = 值
    - 级联对象首先要被创建 或 引用已存在的对象

# 022_bean的继承 - 023

- bean的属性 abstract
- bean的属性 parent : 只是继承xml文件中的配置信息

# 024_bean直接的依赖

- bean的依赖创建顺序 : depend-on - 等依赖对象创建完成后才会被创建
    - 依赖多个对象用逗号分隔

# 025_bean的作用域

- bean的属性  scope : 取值说明

# 026_静态工厂和实例工厂 - 027 -028 

- 静态工厂创建对象 
- 实例工厂创建对象

# 029_ FactoryBean Spring接口

# 030_创建有生命周期bean

- bean的属性 : init-method
- bean的属性 : destory-method , 在容器销毁时候被调用

# 031_bean的后置处理器

- bean的后置处理器 : 可以在bean的初始化前后调用的方法
- BeanPostProcessor接口

# 032_Spring管理连接池

- 管理连接池对象

# 033_引用外部配置文件

- 定义配置文件 : <context:property-placeholder> ${key}取值

# 034_username

- ${username}

# 035_源码文件夹和普通 文件夹

# 036_基于xml的自动转配

- 表示自动赋值 : property是手动赋值
    - bean的属性autowire : 默认default 不自动装配
    - Autowire = byname 用类的属性名作为id在容器中找
    - Autowire=bytype 用属性类型在容器中找
    - Autowire = contractor :首先根据参数类型在容器找, 再根据参数名称作为id
        - 如果没有构造器装配null
        - 如果匹配到多个组件 : 用参数名作为id

# 037_SPEL测试

- ${} : 字面量操作
- ${} 引用其他bean的属性
- `#{}` : 引用外部bean
- 调用静态方法 : `#{T(全类名).静态方法名(参数)}`
- 条用实例方法 : `#{引用的对象.方法名(参数)}`

# 038_spring注解

- 组件注册标签 : Component  Repository  Service Controller
- 开启SpringIOC组件扫描 :`<context:component-scan>`

# 039_修改默认行为

- 注册注解的名称
- 注册组件的作用域

# 040_组件扫描指定包 : 不要exclude

- 扫描时不要包含的  exclude-filter : type   .. ...

# 041_组件扫描指定包 : 只要include

- 扫描时要包含的  :  include-filter
- 要禁用掉默认过滤规则 : use-default-filter  因为默认是扫描所有\

# 042_DI - @Autowire自动注入

# 043_Auto规则

- Autowire原理 : 
    - 根据类型匹配 : 找到多个报错
    - 再根据属性名作为id 找不到报错

# 044_id找不到

- id也匹配不到 : 报错
- @Qualifier : 指定变量名作为id自动注入

# 045_找不到不报错

- Autowire属性 require=false : 表示找不到就放弃

# 046_autowore总结

# 047_方法参数Autowire 和 Qualifier 

- 自动注入原理和属性注入相同

# 048_Autowire和Resource

- 区别 : 可扩展型的区别

# 049_Spring单元测试

# 050_--泛型依赖注入

- 

# 051_--泛型注入依赖原理

- 

# 052_--泛型 的父类类型

- 

# 053_ioc总结

# 054_AOP场景

- aop简介
- 代码环境搭建与日志



001_spring简介

1. 框架
    - 框架是抽取出的搞定可重用代码的一种设计
    - 框架是多个可重用模块的集合, 形成某个领域的整体解决方案
2. spring框架
    - Spring框架是是一个IOC和AOP的容器框架
    - Spring容器包含并且管理应用中的对象的关系以及生命周期
3. spring框架特定
    - 非侵入 : 用Spring开发的应用不依赖Spring的API
    - 依赖注入 : 是对IOC思想的实现
    - 面向切面编程 : 是对面向对象的扩展与增强
    - 组件化 :
    - 为JavaEE开发提供了一站式的解决方案 

002_Spring官网

1. spring 技术栈
    - spring farmwork
    - spring data
    - spring security
    - spring boot
    - spring cloud
    - spring session
    - spring io platform
2. Apache开源组织
    - Tomcat

003_spring模块划分

1. Test : 测试模块

    > - spring-aop-5.1.9.RELEASE

2. Core Container : 核心模块

    > - spring-beans-5.1.9.RELEASE
    > - spring-core-5.1.9.RELEASE
    > - spring-context-5.1.9.RELEASE
    > - spring-expression-5.1.9.RELEASE

3. AOP : 面向切面

    > - spring-aop-5.1.9.RELEASE

4. AOP织入 : 

    > - spring-aspects-5.1.9.RELEASE

5. Instrumentation : 设备

    > - spring-instrument-5.1.9.RELEASE

6. Messaging : 消息

    > - spring-messaging-5.1.9.RELEASE

7.  Data Access : 数据访问

    > - spring-jdbc-5.1.9.RELEASE
    > - spring-orm-5.1.9.RELEASE
    > - spring-tx-5.1.9.RELEASE
    > - spring-oxm-5.1.9.RELEASE
    > - spring-jms-5.1.9.RELEASE

8. WEB

    > - spring-web-5.1.9.RELEASE
    > - spring-webmvc-5.1.9.RELEASE
    > - spring-websocket-5.1.9.RELEASE
    > - spring-webflux-5.1.9.RELEASE

004_ 使用tst

005_安装插件

006_IOC与DI

1. IOC (Inversion of Control)
    - IOC容器用于管理Spring应用中的对象
    - 控制的是资源的获取方式 : 由之前的手动创建方式获取对象改为被动注入的方式获取对象
2. DI (**Dependency Injection**)
    - Ioc 是一种设计思想, DI这对这种设计思想的实现
    - **组件之间依赖关系**由容器在运行期决定 ,容器通过反射的形式将容器中,将容器中的对象注入到对应的属性中, 反射赋值

007_spring hello word - 注册对象

1. 框架学习步骤

    - 导包
    - 配置
    - 测试

2. 注册对象

    - 导包

        ```xml
        spring-core 5.1.8.RELEASE
        spring-beans 5.1.8.RELEASE
        spring-context 5.1.8.RELEASE
        spring-aspects 5.1.8.RELEASE
        spring-test 5.1.8.RELEASE
        commons-logging 1.1.1
        junit 4.12
        ```

    - 配置 application.xml

        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        	
        </beans>
        ```

008_spring hello word - 从容器中获取对象

1. 定义JavaBean

    ```java
    public class Person {
        private String username;
        private Integer age;
        private Boolean gender;
    }
    ```

2. 配置bean

    ```xml
    <bean class="com.panda.ioc.Person" id="person01">
        <property name="username" value="Tom"/>
        <property name="age" value="23"/>
        <property name="gender" value="true"/>
    </bean>
    ```

3. 测试

    - 初始化Spring容器

        ```java
        ApplicationContext ioc = 
            new ClassPathXmlApplicationContext("classpath:application.xml");
        ```

    - 从容器中获取对象

        ```java
        BeanFactory#getBean(java.lang.String)
        ```

009 HelloWord总结

1. IOC初始化

    ```java
    new ClassPathXmlApplicationContext();
    ```

    > 在类路径下读取配置文件,初始化容器

    ```java
    new FileSystemXmlApplicationContext();
    ```

    > 在系统文件路径中读取配置文件,初始化容器

2. 组件的创建过程

    - 在IOC容器初始化时候完成对组件的创建,并且初始化对象的属性
    - 同一个组件在IOC中是单实例的并且在容器启动前已经准备好的
    - 如果获取容器中没有的组件会报错
    - IOC在创建组件时候, 会给组件的属性赋值, 而不是JavaBean的字段

010_根据类型从IOC容器获取bean

1. 根据类型从容器中获取

    ```java
    BeanFactory#getBean(java.lang.Class<T>)
    ```

011_通过构造器为属性赋值:name+value

1. 定义构造器

    ```java
    public Person(String username, Integer age, Boolean gender) {
            this.username = username;
            this.age = age;
            this.gender = gender;
        }
    ```

2. 配置bean

    ```xml
    <bean id="personCus" class="com.panda.ioc.Person">
        <constructor-arg name="username" value="cuns"/>
        <constructor-arg name="age" value="23"/>
        <constructor-arg name="gender" value="true"/>
    </bean>
    ```

3. 测试

012_通过构造器为属性赋值:index+type

1. 定义构造器

2. 配置bean

    ```xml
    <bean id="personIdx" class="com.panda.ioc.Person">
        <constructor-arg index="0" type="java.lang.String" value="cuns"/>
        <constructor-arg index="1" type="java.lang.Integer" value="23"/>
        <constructor-arg index="2" type="java.lang.Boolean" value="true"/>
    </bean>
    ```

3. 测试

013_通过p名称空间为bean赋值

1. 名称空间

    - 在xml 中名称空间是用来防止标签重复
    - 通过名称空间作为标签前缀来区分标签

2. 在spring配置文件中添加名称空间

    - `xmlns:名称空间="http://www.springframework.org/schema/名称空间"` : 此时的名称空间可以作为标签前缀

3. 使用`p名称空间` 为bean赋值

    - 导入p名称空间 : xmlns:p="http://www.springframework.org/schema/p"

    - 使用p名称空间赋值

        ```xml
        <bean id="person1" class="com.panda.ioc.Person" 
              p:age="18" 
              p:username="张三" 
              p:gender="true"/>
        ```

014_为bean的各种属性赋值 - null

1. 基本类型赋值

    ```xml
    <property name="username" value="基本类型"/>
    ```

2. null

    ```xml
    <property name="username">
        <null/>
    </property>
    ```

    - 复杂类型赋值在property标签内部赋值

015_为bean的各种属性赋值 - 引用外部bean

1. 引用外部bean

    ```xml
    <bean id="car1" class="com.panda.ioc.Car">
        <property name="carName" value="BM"/>
        <property name="color" value="red"/>
    </bean>
    <bean id="p3" class="com.panda.ioc.Person">
        <property name="car" ref="car1"/>
    </bean>
    ```

    > ref是严格引用

016_为bean的各种属性赋值 - 引用内部bean

1. 引用内部bean

    ```xml
    <bean id="p4" class="com.panda.ioc.Person">
        <property name="car">
            <bean id="car" class="com.panda.ioc.Car">
                <property name="carName" value="DG"/>
                <property name="color" value="white"/>
            </bean>
        </property>
    </bean>
    ```

    > 内部bean不会被spring管理

017_为bean的各种属性赋值 - list

1. 为List赋值

    ```xml
    <bean id="p5" class="com.panda.ioc.Person">
        <property name="books">
            <list>
                <bean class="com.panda.ioc.Book"></bean>
                <ref bean="book1"/>
            </list>
        </property>
    </bean>
    ```

018_为bean的各种属性赋值 - map

1. 为map赋值

    ```xml
        <bean id="p6" class="com.panda.ioc.Person">
            <property name="map">
                <map>
                    <entry key="key" value="value"/>
                </map>
            </property>
        </bean>
    ```

019_为bean的各种属性赋值 - properties

1. properties

    ```xml
        <bean id="p7" class="com.panda.ioc.Person">
            <property name="properties">
                <props>
                    <prop key="key">value</prop>
                </props>
            </property>
        </bean>
    ```

020_util名称创建可以外部引用的集合

1. 导入util名称空间

    ```xml
    xmlns:util="http://www.springframework.org/schema/util"
    ```

2. util名称空间创建集合

    - list

        ```xml
        <util:list id="list">
        
        </util:list>
        ```

    - map

        ```xml
        <util:map id="map">
        
        </util:map>
        ```

    - properties

        ```xml
        <util:properties id="properties">
            <prop key=""></prop>
        </util:properties>
        ```

021_级联属性赋值

1. 级联属性 : 是属性的属性

    ```xml
    <bean id="p11" class="com.panda.ioc.Person">
        <property name="car" ref="car"/>
        <property name="car.carName" value="carRef"/>
        <property name="car.color" value="black"/>
    </bean>
    ```

    > - 若属性为空时, 操作级联的属性会报错

022_bean的继承

1. bean的属性配置信息重用

    ```xml
    <bean id="p11" class="com.panda.ioc.Person" parent="p1">
    	
    </bean>
    ```

    > 只是继承配置信息

023_创建抽象的模板bean

1. 抽象的bean只能被继承, 不能被实例化

    ```xml
    <bean id="p11" class="com.panda.ioc.Person" abstract="true">
    
    </bean>
    ```

024_bean之间的依赖

1. bean的创建顺序默认是按照配置次序决定

2. bean的属性 depends-on=""

    ```xml
    <bean id="p11" class="com.panda.ioc.Person" depends-on="bean1,bean2">
    </bean>
    ```

    > 需要将所依赖的bean创建后, 该bean才会被创建

025_bean的作用域

1. bean的属性 : scope  默认是单实例

    - scope="prototype" : 多实例,在容器初始化后被创建

    - scope="singleton" : 单实例, 在请求时候才会被实例化

026_027_028_029使用工厂创建对象

1. 静态工厂 : 不需要实例化工厂类

    - 创建静态工厂

        ```java
        public class EmployeeFactoryStatic {
            public static Employee createEmployee(String name){
                Employee employee = new Employee();
                employee.setAge(12);
                employee.setName(name);
                employee.setGender(false);
                employee.setSalary(232412312D);
                return new Employee();
            }
        }
        ```

    - 配置静态工厂

        ```xml
        <bean class="com.panda.factory.EmployeeFactoryStatic" 
              factory-method="createEmployee">
            <constructor-arg name="name" value="test"/>
        </bean>
        ```

    - 测试获取工厂对象

2. 实例工厂 : 需要实例化工厂类, 实例工厂需要在spring中定义

    - 创建实例工厂

        ```xml
        public class EmployeeFactoryInstance {
            public  Employee createEmployee(String name){
                Employee employee = new Employee();
                employee.setName(name);
                employee.setAge(12);
                employee.setGender(false);
                employee.setSalary(23242D);
                return employee;
            }
        }
        ```

    - 配置实例工厂

        ```java
        // 1. 将实例工厂配置在spring中
        <bean id="instance" class="com.panda.factory.EmployeeFactoryInstance">
        </bean>
        
        // 2. 配置对象从实例工厂中获取
        <bean id="employee2" 
            class="com.panda.factory.Employee" 
                factory-bean="instance" 
                factory-method="createEmployee">
        	<constructor-arg name="name" value="instance"/>
        </bean>
        ```

        > 工厂传参

    - 继承spring的FactoryBean

        - 自定义类实现Spring工厂类

            ```java
            public class SpringFactory implements FactoryBean<Employee> {
                public Employee getObject() throws Exception {
                    Employee employee = new Employee();
                    employee.setName("spring");
                    employee.setAge(12);
                    employee.setGender(false);
                    employee.setSalary(23242D);
                    return employee;
                }
            
                public Class<?> getObjectType() {
                    return Employee.class;
                }
            
                public boolean isSingleton() {
                    return false;
                }
            }
            ```

        - 配置工厂类

            ```xml
            <bean id="spring" class="com.panda.factory.SpringFactory"></bean>
            ```

030_创建带声明周期的bean

1. bean的声明周期
    - 单实例bean : 容器启动时候回创建,容器关闭回销毁创建的bean
    - 对胜利bean : 获取时候才会初始化bean
2. bean的属性:init-method="初始化方法名"
3. bean的属性:destroy-method="销毁方法"

031_bean的后置处理器

1. 后置处理器

    - 可以在bean的初始化前后调用的方法
    - Spring的后置处理器接口 : BeanPostProcessor

    ```java
    public class MyBeanPost implements BeanPostProcessor {
        public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
            return null;
        }
    
        public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
            return null;
        }
    }
    ```

    - postProcessAfterInitialization: 表示
        - 初始化之前调用
    - postProcessBeforeInitialization:表示
        - 初始化方法之后调用

    > - bean : 那个bean要被初始化
    > - beanName : bean的name
    > - 需要将要初始化的bean返回

2. 将后置处理器注册进spring 

032_Spring管理连接处

033_引入外部配置文件

1. 依赖context名称空间

2. 引入外部文件

    ```xml
    <context:property-placeholder location="classpath:jdbc.properties"/>
    ```

    - location : 指定文件位置

3. 读取配置文件数据

    ```xml
    ${key}
    ```

036_基于xml的自动装备

- 用于装备容器中bean中的属性

1. bean的属性 : autowire 

    - autowire="default" 默认 不自动装配

    - autowire="byName" : 根据名称自动装配
        - 属性名作为id 在容器找匹配
    - autowire="byType" : 根据类型自动转配
        - 根据属性名对应的类型在容器中匹配
    - autowire="constructor" : 根据构造器自动转配
        - 根据构造器的参数的类型和名称注入

038_注解注入bean

1. 注入bean的标签

    - @Component
    - @Repository
    - @Service
    - @Controller

    > 给类上添加注解, 可以快速的将这个组件加入到IOC容器中
    >
    > 注解的value属性 : 用于重新制定组件的ID

2. 修改组件作用域

    - @Scope 标签的value属性

040_041context名称空间

1. 指定扫描包时候添加过滤的组件

    - context:component-scan 

        > 子标签 : context:exclude-filter : type 指定排除规则,
        >
        > - annotation : 注解类型
        > - assignable : 排除指定类
        > - aspectj : aspectj表达式
        > - custom : 自定义typeFilter实现类中指定
        > - regex : 使用正则表达式

2. 指定扫描指定的组件

    - 需要禁用默认规则 : use-default-filter = false

        > context:include-filter type 指定添加规则

042_043_044自动注入

1. @Autowire

    - 给属性添加注解 : 将Spring中找到对应的组件自动注入到属性中

        > 原理 : 第一步安装属性的类型匹配
        >
        > 第二步 : 如果容器中有多个类型,按照变量名作为ID继续匹配

2. @Qualifier

    - 给@Autowire指定注入的ID名

045_自动注入会报错

1. @Autowire的属性require 
    - 设置为false : 如果找不到则不需要报错,装备为null

047_给方法形参添加

1. 会根据方法的形参类型与名称自动注入到参数中
2. 也可以用@Qualifier指定注入的ID名

048_@Resource

1. @Resource是Javax规范,扩展性强,切换容器也可以识别
2. @Autowire 功能强, 是Spring标准

049_Spring单元测试

1. @Runwith
2. @ContextConfiguration

050_泛型依赖注入

1. Spring中使用泛型匹配时候, 采用反射获取泛型类型, 从而对对应的类型实现自动注入



