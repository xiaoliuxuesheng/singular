# 001 - 002

- 本教程的课程记录以及相关资料说明
- 引出课程的学习重要性,用面试题引出
  - 字符串1是否包含字符串2, 或者包含的次数 -> 暴力匹配 或 KMP算法
  - 汉诺塔游戏  ->  分治算法
  - 八皇后问题  ->  回溯算法
  - 马踏棋盘问题  -> 图的深度优先遍历算法(DFS)

# 003 - 004课程内容

- 数据结构与算法概述

  - 算法是程序的灵魂, 海量数据的高效执行
  - 数据结构是算法的基础
  - 主流的框架底层是优秀的数据结构和算法
  - 学习过程是枯燥的并且是困难的, 需要花费时间研究

- 第一章 内容简绍

  - 经典面试题开场
  - 数据结构和算法的重要性
  - 内容介绍

- 第二章 数据结构和算法介绍

  - 数据结构的介绍
  - 数据结构和算法的关系
  - 实际编程数的问题
  - 线性结构和非线性结

- 第三章 稀疏数组和队列

  - 稀疏sparsearray数组
  - 队列

- 第四章 列表

  - 列表介绍
  - 单链表
  - 双向列表
  - 单向环形列表
  - josephu问题

- 第五章 栈

  - 栈的一个实际需求
  - 栈的介绍
  - 栈的应用场景栈的快速入门
  - 栈实现综合计算器
  - 前缀. 中缀, 后缀表达式
  - 逆波兰计算器
  - 中缀表达式转为后缀表达式
  - 逆波兰计算器完整

- 第六章 递归

  - 递归的应用场景
  - 递归的概念
  - 递归的调用机制
  - 递归解决的问题
  - 递归需要遵守的原则
  - 迷宫问题
  - 八皇后问题

- 第七章 排序算法

  - 排序算法介绍
  - 算法的时间复杂度
  - 算法的空间复杂度
  - 冒泡麦排序
  - 选择排序
  - 快速排序
  - 归并排序
  - 希尔排序
  - 技术排序
  - 常用排序算法和总结

- 第八章 查找算法

  - 查找算法介绍
  - 线性查找算法
  - 二分查找算法
  - 插值查找算法
  - 斐波那契查找算法

- 第九章 哈希表

  - 哈希表基本原理
  - 哈希表 散列

- 第十章 树结构

  - 二叉树
  - 顺序存储二叉树
  - 线索化叉树

- 第十一章 树结构实际应用

  - 堆排序
  - 赫夫曼树
  - 赫夫曼编码
  - 二叉排序树
  - 平衡二叉树

- 第十二章  多路查找树

  - 二叉树与B树
  - 2-3树
  - B树 B+树  B*树

- 第十三章 图

  - 图的基本介绍
  - 图的常用概念
  - 图的快速入门案例
  - 图的深度优先搜索算法介绍
  - 图的创建和深度优先搜索算法

- 第十四章 程序员必会的十大算法

  - 二分查找算法
  - 分治算法
  - 动态规划算法
  - KMP算法
  - 贪心算法
  - 普利姆算法
  - 克鲁斯卡算法
  - 迪杰斯特算法
  - 弗洛伊德算法
  - 马踏棋盘算法

# 005 代码中的问题

- 代码中的问题
  - String.replaceAll()   -   单列表
  - 五子棋存盘
  - 约瑟夫丢手帕问题
  - 修路问题
  - 最短路径
  - 汉诺塔
  - 八皇后  
- 解决问题方案 :  数据结构与算法的选择

# 006 数据结构类型

- 数据结构分类
    - 线性结构:① 元素之间存在一对一的线性关系② 线性结构有两种不同的存储结构;顺序存储结构(顺序表特点是内存元素之间的内存空间是连续的)和链式存储结构(链表特点是内存不一定是连续的,特点是一个元素会包含一个或两个相邻元素的引用)② 常见的线性结构 : 数组 队列 链表 栈
    - 非线性结构:包含二维数组 多维数组 广义表 树结构 图结构

# 007 稀疏数组和队列

- 引出问题:如何保存五子棋盘数据,1表示黑子2表示白子0表示空白,用二维数组保存数据
- 存在问题:保存的数据中如果大部分为空白,这保存大量的0这种表示空白的数据
- 解决方案:稀疏数组-当一个数组中大部分元素为同一个数值时,可以使用稀疏数组保存改数组,压缩数据
    - 记录数组总共有几行几列,和多少个不同的值
    - 把具有不同的值的元素记录在一个小规模的数组中(缩小数据规模)
- 应用场景:

# 008 稀疏数组应用实例

- 实例 : 使用稀疏数组保存二维数组数据或地图
- 思路分析: 第一行记录几行几列多少不同的值,第2行 记录第一个数字的行数列数和值
- 二维数组转稀疏数组思路
    - 遍历得到有效数据个数count
    - 根据count创建稀疏数组,
    - 将二维数组的有效数据存入到稀疏数组
- 稀疏数组转二维数组
    - 读取稀疏数组第一行,创建原始二维数组
    - 再读取稀疏数组后几行数据,将有效数据保存到原始二维数组

# 009 代码实现

- 二维数组的定义

    ```java
    数据类型[][] 数组名 = new 数据类型[二维数组的长度/包含的一维数组的个数][每个一维数组的长度];
    
    arr[0]---下标为0的位置上的一维数组
    
    arr[1][3]---如果要获取具体的元素需要两个下标
    ```

    ```java
    数据类型[][] 数组名 = {{元素},{元素1， 元素2},……};
    ```

- 二维数组转稀疏数组

    ```java
    private int[][] arrayToSparse(int[][] arr) {
        // 第一 统计二维数组中有效值的数量
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (arr[i][j] != 0) {
                    count++;
                }
            }
        }
        
        // 第二 根有效值数量可定义一个稀疏数组(行=有效数＋1,列=3列)
        int sparse[][] = new int[count + 1][3];
        
        // 第三 定义第一行稀疏数组的元信息
        sparse[0][0] = arr.length;
        sparse[0][1] = arr[0].length;
        sparse[0][2] = count;
        
        // 第四 遍历二维数组向稀疏数组中添加有效数值的信息
        int row = 1;
        for (int a = 0; a < arr.length; a++) {
            for (int b = 0; b < arr[0].length; b++) {
                if (arr[a][b] != 0) {
                    sparse[row][0] = a;
                    sparse[row][1] = b;
                    sparse[row][2] = arr[a][b];
                    row++;
                }
            }
        }
        return sparse;
    }
    ```

- 稀疏数组转换为二维数组

    ```java
    private int[][] sparseToArray(int arr[][]) {
        // 第一 根据稀疏数组第一行元信息构建二维数组
        int result[][] = new int[arr[0][0]][arr[0][1]];
        
        // 第二 遍历稀疏数组向二维数组中添加值
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                result[arr[i][0]][arr[i][1]] = arr[i][2];
            }
        }
        return result;
    }
    ```

    