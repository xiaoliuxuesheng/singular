# 第一章 JVM与Java体系结构

## 1.1 前言

1. 为什么学习JVM

   - 线上调优无从下手

   - 面试问题无从答起

   - 对于Java技术的核心Java虚拟机了解甚少：侧重的关注了上层框架，没关注底层技术；

   - 计算机系统体系对开发人员越来越远，可以不通过底层技术使用高级语言就可以开发应用；

   - 如何让系统变的更快？

   - 如何避免系统出现故障？

2. 学习路线：主要分为三大部分：①内存结构②垃圾回收③字节码优化④类加载器

   ![image-20220530213344915](.\resource\point03_JVM\image-20220530213344915.png)

   - ClassLoader：类加载器，从源码编译为字节码
   - JMV内存结构：字节码在JVM中的执行机制
   - 执行引擎：垃圾回收机制，解释器

## 1.2 Java与JVM介绍

1. 编程语言：按照语言的抽象等级，由低到高分为机器语言、汇编语言与高级语言；Java是一门面向对象的高级编程语言；

2. 虚拟机：是一台虚拟计算机，可以用来执行一系列虚拟计算机指令。

3. JVM（Java Virtual Machine）：Java虚拟机，`JVM`是一种用于计算设备的**规范**，它是一个**虚构**的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的；Java虚拟机是二进制字节码的运行环境，负责装载**字节码**到其内部，解释/编译为对应平台的机器指令执行。

   > 一次编写，到处运行
   >
   > 自动内存管理，垃圾回收功能

4. JVM、JRE、JDK

   ![image-20220530212333397](.\resource\point03_JVM\image-20220530212333397.png)

   - JVM：Java虚拟机(JVM)屏蔽了与具体操作系统平台相关的信息，实现了程序与操作系统的分离；
   - JRE：在JVM基础之上，封装了基础类库，操作JVM
   - JDK：对基础类库添加的开发工具

## 1.3 Java发展

​	Java语言的诞生具有一定的戏剧性，它并不是经过精心的策划、制作，最后产生的划时代产品，从某种角度来看，java语言的诞生完全是一种误会。这又是怎么说呢？

​	1990年年末，Sun公司预料嵌入式系统将在未来家用电器领域大显身手。于是Sun公司成立了一个由James Gosling领导的“Green计划 ”，准备为下一代智能家电（电视机、微波炉、电话）编写一个通用控制系统。

​	该团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家Bill Joy,发现C++和可用的API在某些方面存在很大的问题。而且工作小组使用的是嵌入式平台，可用的系统资源极其有限。并且很多成员都发现C++太复杂，以致很多开发者经常错误使用。而且C++缺少垃圾回收系统、可移植性、分布式和多线程等功能。

​	根据可用的资金，Bill Joy 决定开发一种新语言，他提议在C++的基础上，开发一种面向对象的环境。于是，Gosling试图通过修改和扩展C++的功能来满足这个要求，但是后来他放弃了。他决定创造一种全新的语言：Oak.（他们都具有不将就的精神、在开发某一项科技的时候得具有资金的支持以及各种创新精神）

​	到了1992年的夏天，Green计划已经完成了新平台的部分功能，包括Green操作系统。Oak的程序设计语言、类库等。同年11月，Green计划被转化成“FirstPerson有限公司”，一个Sun公司的全资子公司。

​	FirstPerson团队致力于创建一种高度互动的设备。当时代华纳公司发布了一个关于电视机顶盒的征求提议书时，FirstPerson团队改变了他们的目标，作为对征求提议书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多的控制权，因此FirstPerson的投标败给了SGI。同时，3DO公司另外一笔关于机顶盒的交易没有成功。此时，可怜的Green项目几乎接近夭折，甚至Green项目的一半成员也被调到了其他的项目组。

​	正如中国古代的寓言所言：塞翁失马，焉知非福？如果Green项目在机顶盒平台投标成功，也许就不会诞生Java这门伟大的语言了。

​	1994年夏天，互联网和浏览器的出现不仅给广大互联网的用户带来了福音，也给Oak语言带来了新的生机。Gosling立即意识到，这是一个机会，于是对Oak进行了小规模的改造，到了1994年秋，小组中的Naughton和Jonathan Payne完成了第一个Java语言的网页浏览器：WebRunner.Sun公司实验室主任Bert Sutherland 和技术总监Eric Schmict 观看了该浏览器的演示，对该浏览器的效果给予了高度评价。当时的Oak这个商品已经被注册，于是只得将Oak更名为Java.

​	Sun公司在1995年年初发布了Java语言，Sun公司直接把Java放到互联网上，免费给大家使用，甚至连源代码也不保密，也放到互联网上向所有人公开。

​	几个月后，让所有人都吃惊的事情发生了：Java成了互联网上最热门的宝贝。竟然有10万多人次访问了Sun公司的网页，下载了Java语言。然后，互联网上立即就有了数不清的Java小程序（也就Applet）,演示着各种小动画、小游戏等。

​	Java 语言终于眼眉吐气了 ，成为了一种广为人知的编程语言。

​	在Java语言出现之前，互联网的网页实质上就像一张纸，不会有任何动态的内容。有了Java语言之后，浏览器的功能被扩大了，Java程序可以直接在浏览器里运行，可以直接与远程服务器交互：用Java语言编程，可以在互联网上像传送电子邮件一样方便地传送程序文件！

​	1995年，Sun虽然推出了Java，但这只是一种语言，如果想开发复杂的应用程序，必须要有一个强大的开发类库。因此，Sun在1996年年初 发布了JDK1.0.这个版本包括两部分：运行环境（即JRE）和开发环境（即JDK）.运行环境包括核心API、集成API、用户界面API、发布技术、Java虚拟机（JVM）5个部分;开发环境包括编译Java程序的编译器（即Javac命令）。

​	接着，Sun在1997年2月18日发布了JDK1.1。JDK1.1增加了JIT（即时编译）编译器。JIT和传统的编译器不同，传统的编译器是编译一条，运行完成后将其扔掉；而JIT会将经常用到的指令保存在内存中，当下调用时就不需要重新编译了，通过这种方式让JDK在效率上有了较大提升。

​	但一直以来，Java主要的应用就是网页上的Applet以及一些移动设备。到了1996年年底，Flash面世了，这是一种更加简单的动画设计软件：使用Flash几乎无须任何编程语言知识，就可以做出丰富多彩的动画。随后Flash增加了ActionScript编程脚本，Flash逐渐蚕食了Java在网页上有了较大提升。

​	从1995年Java诞生到1998年年底，Java语言虽然成为了互联网上广泛使用的编程语言，但它并没有找到一个准确的定位，也没有找到它必须存在的理由：Java语言可以编写Applet,而Flash一样可以做到，而且更快，开发成本更低。

​	直到1998年12月，Sun发布了Java历史上最重要的JDK版本：JDK1.2，伴随着JDK1.2一同发布的还有JSP/Servlet、EJB等规范，并将Java分成J2EE、J2SE和J2ME三个版本。

- J2ME：主要用于控制移动设备和信息家电等有限存储的设备。
- J2SE：整个Java技术的核心和基础，它是J2ME、J2EE编程的基础，
- J2EE：Java技术中应用最广泛的部分，J2EE提供了企业应用开发相关的完整解决方案。这标志着Java已经吹响了向企业、桌面和移动三个领域进军的号角，标志着Java已经进入Java2时代，这个时期也是Java飞速发展的时期。

​	在Java2中，Java发生了很多革命性的变化，而这些革命性的变化一直沿用到现在，对于Java的发展形成了深远的影响。知道今天还经常看到J2EE、J2ME等名称。不仅如此，JDK1.2还把它的API分成了三类。

- 核心API：由Sun公司制定的基本的API，所有的Java平台都应该提供。这就是平常所说的Java核心类库。
- 可选API：这是Sun为JDK提供的扩充API，这些API因平台的不同而不同。
- 特殊API：用于满足特殊要求的API。如用于JCA和JCE等第三方加密类库。

​	2002年，Sun发布了JDK历史上最成熟的版本：JDK1.4成为发展最快的一个JDK版本。JDK1.4已经可以使用Java实现大多数的应用了。在此期间，Java语言在企业应用领域大放异彩，涌现出大量基于java语言的开源框架 ：Struts、WebWork、Hibernate、Spring等；大量企业应用服务器也开始涌现：WebLogic、WebSphere、JBoss等，这些都标志着Java语言进入了飞速发展时期。

​	2004年10月，Sun发布了万众期待的JDK1.5,同时，Sun将JDK1.5改名为Java SE5.0，J2EE、J2ME也相应地改名为Java EE和Java ME。JDK1.5增加了诸如泛型、增强的for语句、可变数量的形参、注释、自动拆箱和装箱等功能；同时，也发布了新的企业级平台规范，如通过注释等新特性来简化EJB的复杂性，并推出了自己的MVC框架规范：JSF,JSF规范类似于ASP.NET的服务器端控件，通过它可以快速地构建复杂的JSP界面。

​	2006年12月，Sun公司发布了JDK1.6(也被称为Java EE 6)。一直以来，Sun公司维持着大约2年发布一次JDK新版本的习惯。

​	但在2009年4月20日，Oracle宣布将收购Sun公司。Sun倒下了，不过Java的大旗依然猎猎作响。2011年7月28日，Oracle公司终于"如约" 发布了 Java SE 7——这次版本的升级经过了将近5年时间。Java SE 7也是Oracle发布的第一个Java版本，引入了二进制整数、支持字符串的switch语句、棱形语法、多异常捕抓、自动关闭资源的try语言等新特性。

​	2014年3月18日，Oracle公司发不了Java SE8,这次版本升级为Java带来了全新的Lambda表达式、流式编程等大量新特性，这些新特性使得Java变得更加强大。

​	2017年9月22日，Oracle公司发布了Java SE 9，这次版本升级强化了Java的模块化系统，让庞大的Java语言更轻量化，而且采用了更高效、更智能的GI 垃圾回收器，并在核心类库上进行了大量更新，可以进一步简化编程；但对语法本身更新并不多（毕竟Java语言已经足够成熟）

## 1.5 JVM整体结构

[![hWg6nH.png](https://z3.ax1x.com/2021/09/05/hWg6nH.png)](https://imgtu.com/i/hWg6nH)

- JVM虚拟机主要分为三个结构
  1. 类加载子系统：虚拟机首先需要把编译完成的字节码文件通过类加载器来加载到运行时数据区域
  2. 运行时数据区：在运行时数据区里存储类Class文件元数据(方法区),对象和数组(堆)，方法参数局部变量(栈)等。
  3. 执行引擎：主要包括解释器，JIT及时编译器（热点代码），GC（垃圾回收器）；java 语言的优势之一就是它的自动内存管理，主要回收运行时数据区域的堆内存里的数据，执行引擎作用是将高级语言解析为机器语言；
- Java代码执行流程简述
  1. Java源文件通过Java编译器生成字节码文件
  2. Java虚拟机根据字节码文件通过类加载器将字节码封装为Class对象并保存到运行时数据区；
  3. JIT编译器将运行数据及时编译

## 1.6 Java代码执行流程

[![hWWN7j.png](https://z3.ax1x.com/2021/09/05/hWWN7j.png)](https://imgtu.com/i/hWWN7j)

## 1.7 JVM架构模型

1. 基于栈的指令集架构
   - 设计和实现更简单，适用于资源受限的系统
   - 避开了寄存器分配难题，使用零地址指令分配
   - 指令流中指令大部分是零地址指令，执行依赖操作栈，指令集更小，编译器容器实现
   - 
2. 基于寄存器的指令集架构

## 1.8 JVM生命周期

1. JVM的生命周期

   - JVM实例的诞生：当一个程序启动，伴随的就是一个jvm实例的诞生，当这个程序关闭退出，这个jvm实例就随之消亡。
   - JVM实例的运行：main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用。
   - JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；

2. java类的生命周期

   <img src='./imgs/01_Java类的生命周期'/>	

## 1.9 JVM发展历程

1. Sun Classic

   Classic VM是世界上第一款商用Java虚拟机。这款虚拟机只能使用纯解释器方式来执行Java代码，如果要使用JIT编译器，就必须进行外挂。但是假如外挂了JIT编译器，JIT编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。此时解释器和编译器不能配合工作。

2. Exact VM

   Exact VM因它使用准确式内存管理而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。

3. Sun HotSpot VM

   HotSpot VM既继承了Sun之前两款商用虚拟机的优点，HotSpot指的就是它的热点代码探测技术，HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。

4.  BEA JRockit

   号称“世界上速度最快的Java虚拟机”（广告词），BEA公司将其发展为一款专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于专注于服务器端应用，它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。

5. IBM J9 VM

   IBM J9 VM是IBM公司目前主力发展的Java虚拟机，它是一款设计上从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java应用。

6. Azul VM

   特定硬件平台专有的虚拟机，Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机，每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、为专有硬件优化的线程调度等优秀特性。

7. BEA Liquid VM

   特定硬件平台专有的虚拟机，是BEA公司开发的，可以直接运行在自家Hypervisor系统上的JRockit VM的虚拟化版本，Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态/用户态的切换等，这样可以最大限度地发挥硬件的能力，提升Java程序的执行性能。

8. Apache Harmony

   是一个Apache软件基金会旗下以Apache License协议开源的实际兼容于JDK 1.5和JDK 1.6的Java程序运行平台，Apache基金会曾要求Sun公司提供TCK的使用授权，但是一直遭到拒绝，直到Oracle公司收购了Sun公司之后，双方关系越闹越僵，最终导致Apache愤然退出JCP（Java Community Process）组织。 	

# 第二章 类加载与子系统

## 2.1 内存结构概述

[![h5hqcn.jpg](https://z3.ax1x.com/2021/09/07/h5hqcn.jpg)](https://imgtu.com/i/h5hqcn)

- 内存结构简述：Java源码通过类加载子系统（ClassLoader）将编译后的字节码加载到JVM内存中，执行引擎根据JVM内存中的指令执行字节码指令，
- 
- 字节码文件加载到内存中，加载字节码到内存的使用到类加载子系统，加载完成在内存中生成Class对象保存在方法区同时类中静态常量保存在常量池。执行引擎从运行时数据区获取数据执行字节码指令
  - 运行时在堆中创建对象
  - 指令执行以来程序计数器
  - 执行引擎根据程序计数器执行本地方法栈中栈帧

## 2.2 类加载器与类加载过程

<img src='./imgs/04_类加载子系统'/>

1. 类加载器子系统作用
   - 负责从文件系统或网络中加载具有特定文件头标识的class文件，并转换成`java.lang.Class`类的一个实例，这个实例是读取方法区内存中该类的唯一入口；
     - 可以根据Class实例获取到加载这个类的类加载器的类型；
     - 可以根据Class实例生成的对象可以获取到Class对象；
   - ClassLoader只负责class文件的加载，至于是否可以运行是由ExcutionEngine决定；
   - 将加载的类的信息存放在称为方法区的内存空间：方法区出来类信息还会存放运行时常量信息，可以包括字符串字面量和数字常量
2. 字节码加载到内存的过程分为三个环节：JClassLib、PXBinaryViewerSetup
   - Loading（加载）：
     - 作用：负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载
     - 首先将类`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内;
     - 然后在堆区创建一个java.lang.Class对象，用来封装类在方法区中的数据结构
   - Linking（链接）：
     - 链接验证：校验是防止不合法的.class文件；
     - 链接准备：为类变量分配内存并设置该类变量的初始值，final修饰的static在编译时候就分配好了，这个阶段不会为实例变量分配和初始化，实例变量是随着对象的创建从而分配；
     - 链接解析：将常量池内的符号引用转换为直接引用
   - Initialization（初始化）：
     - 初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，clinit()的过程；
     - clinit()是javac编译器自动收集类中所有类变量的赋值动作和静态代码块语句的过程；
     - JVM保证子类的clinit()执行之前，父类的clinit()已经执行完毕；
     - 虚拟机必须保证一个类的clinit()方法在多线程下是同步加锁。

## 2.3 类加载器分类

### 1. 类加载器类型

<img src='./imgs/05_类加载器类型'/>

- JVM加载器类型理论上只有两种：引导类加载器和自定义类加载器； 
- 自定义类加载器的定义：将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器；

### :anchor:引导类加载器

- 这是JVM的根ClassLoader，它是用C++实现的，

- JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中`jre/lib/rt.jar`、`resources.jar`、`sun.boot.class.path`中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。

  ```java
  // 获取BootStrapClassLoader能够加载的路径
  URL[] urls = sun.misc.Laucher.BootstrapClasspath().getUrls();
  ```

- BootstrapClassLoader是最先加载的，它然后依次加载出ExtClassLoader、AppClassLoader对象。

- 出于安全考虑，bootstrap启动类加载器只加载java、javax、sun开头的类。

### :anchor: 扩展类加载器

- 是派生于Classloader类，由Java语言编写，父类（上级）类加载器是启动类加载器；

- JVM用此扩展类加载器来加载扩展功能的一些jar包：JDK安装目录`jre/lib/ext`子目录下的类库

  ```java
  // 获取扩展类加载器能够加载的路径
  String property = System.getProperty("java.ext.dirs");
  ```

### :anchor: 系统类加载器

- 是派生于Classloader类，由Java语言编写，父类（上级）类加载器是启动类加载器；
- JVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。

### :anchor: 用户自定义类加载器

1. 为什么要用用户自定义类加载器
   - 因为安全性更高一点，子类加载器是没法加载父类加载器加载的类的，父类加载过的类不需要重复加载，这样防止恶意代码冒充java核心库
   - 可以修改类的加载方式
2. 如果自定类加载器
   - 思路：继承ClassLoader，覆盖核心方法findClass，定义私有方法loadClass将其转化成二进制数据流，从而加载到Class类。

JVM内存

- PC寄存器（程序计数器）：每个线程保存一份，记录当前线程运行的位置
- 栈：虚拟机栈，每个线程一份，一个方法就是一个栈帧
- 本地方法栈：
- 堆区：Java对象存储位置
- 方法区：存放类信息、常量、方法信息

执行引擎

- 

## 2.4 Classloader的使用说明

### 1. 获取类的类加载器的方式

```java
// 扩展类加载器Main
ClassLoader classLoader = MainTest.class.getClassLoader();
// 表示当前线程的类加载器——应用程序类加载器
ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
// 启动类加载器
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
```

### 2. 类加载器常用API



## 2.5 双亲委派机制与沙箱机制

<img src='./imgs/06_双亲委派机制'/>

- 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

## 2.6 其他

:anchor: JVM中两个Class是否是同一个

- 类的全限定名是否相同
- 类的类加载器是否是同一个

:anchor:JVM必须指定一个类是由启动类加载器加载的还是由用户类加载器加载的

- 如果一个类是由用户类加载器加载的，那么JVM会将这个类加载器的应用作为类信息的一部分保存在方法区

:anchor: 类的主动加载和被动加载

- 判断标准是这个类是否导致类的初始化，被动初始化会调用clinit()初始化方法；

# 第三章 运行时数据区与线程

## 3.1 JVM内存基本结构图

<img src='./imgs/07_JVM基础基本模型'/>

1. 字节码文件被加载完毕后，会在内存中保存一份数据结构，JVM执行引擎在运行时数据在这块内存中获取
2. 线程共享的数据结构：方法区、堆；
3. 线程独享的数据结构：程序计数器、本地方法栈、虚拟机栈；
4. 每个JVM运行都有一个Runtime实例：运行时实例；

## 3.2 线程

- 线程是一个程序里的运行单元，在JVM中允许一个应用有多个线程并行执行
- 在Hotspot VM中每个线程与操作系统的本地线程直接映射，操作系统负责所有线程的安排调度到任何一个可用的CUP上：本地线程初始化成功就会调用Java线程的run（）方法

# 第四章 程序计数器

- PC寄存器（ PC register ）：每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 
- 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。
- 每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
- 这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 如果执行的是一个Native方法，那这个计数器是空的。

# 第五章 虚拟机栈



# 第六章 本地方法接口

# 第七章 本地方法栈

# 第八章 堆

# 第九章 方法区

# 第十章 对象实例化内存布局

# 第十一章 直接内存

# 第十二章 执行引擎 

# 第十三章 StringTable

# 第十四章 垃圾回收概述

## 14.1 GC学习概述

​	学习要求概述：学JVM最终目的是做到性能优化(方案一:业务代码层面的优化;方案二:底层虚拟机的优化)，但是对底层虚拟机的优化前提是需要学会可视化工具进行性能检测，所以必须要知道内存的分配与回收策略；对内存分配的理解也必须要知道JVM内存结构，而JVM内存结构是根据类加载器，class文件结构，执行引擎所决定的；	垃圾回收机制每个版本在不断的优化中，学无止境；

## 14.2 为什么需要GC

1. 什么是垃圾：垃圾回收在第一门开始使用内存动态分配时就遇到的问题，关于垃圾回收的三个经典问题：

   - 哪些内存需要回收：指在运行程序中没有任何内存指针指向的对象
   - 什么时候回收
   - 如何回收

   垃圾收集机制是Java的招牌能力，极大的提高的开发效率，如今Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景对垃圾收集有着不同的挑战；

2. 为什么需要GC：如果不及时对垃圾进行清理，这些垃圾对象所占用的堆空间内存空间无法被其他对象使用，可能会导致内存溢出；GC可以删除无用对象，整理内存碎片，节省内存，保证程序正常运行；

3. 早期垃圾回收：早期C/C++垃圾回收是手工进行的，频繁的申请和释放会造成管理的负担；

4. Java垃圾回收机制

   - 自动内存管理：开发人员无需手动参与内存分配与回收，但是会弱化开发人员对内存问题的处理；
   - 当需要排查内存问题时候，需要程序员会使用自动化技术实施必要的监控和调节
   - Java堆是垃圾回收的重点区域：①频繁收集Young区、②较少收集Old区、③基本不懂Perm区（元空间）

# 第十五章 垃圾回收相关算法

> 1. 标记阶段原理：用于判断对象是否存活；在堆存放几乎所有Java实例对象，在GC执行回收之前，首先需要区分出内存中对象的存活状态，只有被标记死亡的对象才会被回收；判断存活的方式
>
>    - 引用计数法：每个对象保存一个整形的引用计数器，用于记录对象被引用的情况；优点：实现简单，判断效率高。缺点：需要独立的字段存储计数器，增产存储空间；计数器的更新拯救了时间的开销；无法处理循环引用；
>
>    - 可达性分析算法：有效的解决引用计数算法中循环引用的问题；基本思路：可达性算法是以更对象集合（GC Roots）为起始点，按照从上到下的方式搜索跟对象集合所连接的目标对象是否可达；内存中存活对象会被跟对象直接或间接连接着，这条连接路径成为引用链；如果目标对象没有引用链可以标记为垃圾对象；如果要使用可达性分析算法，分析工作必须在一个保障一致性的快照中进行；
>
> 2. GC Roots：包含（由于Root采用栈方式存放变量和指针，如果一个指针保存了堆内存里面的对象，但是自己又不存在堆内存中，那么它就是一个Root）
>
>    - 虚拟机栈中的引用对象：线程调用方法中的参数等等；
>    - 本地方法栈引用对象：
>    - 方法区中静态属性引用的对象：
>    - 方法区中常量引用的对象
>    - 所有被同步所synchronized持有的对象
>    - Java虚拟机内部的引用
>    - 反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等；
>    - 根据用户所选的垃圾收集器以及当前回收的区域不同，还可以有其他对象临时性的加入到GC Roots，比如分代收集和局部回收；
>
> 3. 对象的finalization机制：Java语言提供对象终止机制来允许开发人员提供对像被销毁之前的自定义处理逻辑；当对象被回收之前，总会先调用这个对象的finalize()方法；
>
> 4. MAT与JProfiler的GC Roots溯源
>
> 5. 清除阶段：标记-清除算法
>
> 6. 清除阶段：复制算法
>
> 7. 清除阶段：标记压缩算法
>
> 8. 小结
>
> 9. 分代收集算法
>
> 10. 增量收集算法，分区算法

## 15.1 标记阶段

​	标记阶段用于判断对象是否存活，在堆存放几乎所有Java实例对象，在GC执行回收之前，首先需要区分出内存中对象的存活状态，只有被标记死亡的对象才会被回收；当一个对象已经不再被任何存活的对象继续引用时，就可以判定为死亡，判断死亡的方式：①引用计数算法、②可达性分析算法

### 1. 引用计数算法

​	引用计数算法：对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况：只要对象被引用一次，引用计数就加1，当引用失效，引用计数就减1，只要对象的引用计数器的值为0，即表示对象不可能被使用，可以进行回收

- 优点：实现简单，垃圾对象容易辨识，判定效率高，回收没有延迟性；
- 缺点：
  - 需要单独的字段存储计数器，增加了存储空间的开销；
  - 每次赋值都需要更新计数器，增加了对这个计数器的值的计算开销；
  - 引用计数致命问题，无法处理循环引用的情况，所以在Java的垃圾回收机制中没有采用这类算法

引用计数算法：Java没有使用引用计算算法案例

```java
System.gc();
```

### 2. 可达性分析算法

​	可达性分析：也称为根搜索算法或者追踪性垃圾收集，可以有效的解决在引用计数中循环引用的问题，防止内存泄漏的发送，这种类型的垃圾收集器通常叫做追踪性垃圾收集；基本思路：

- 可达性算法是以更对象集合（GC Roots）为起始点，按照从上到下的方式搜索跟对象集合所连接的目标对象是否可达
- 使用可达性分析算法那，内存中存活对象会被跟对象直接或间接连接着，这条连接路径成为引用链；
- 如果目标对象没有引用链可以标记为垃圾对象；
- 如果要使用可达性分析算法，分析工作必须在一个保障一致性的快照中进行；

​	GC Roots：包含（由于Root采用栈方式存放变量和指针，如果一个指针保存了堆内存里面的对象，但是自己又不存在堆内存中，那么它就是一个Root），GC Roots包括以下元素：

- 虚拟机栈中的引用对象：线程调用方法中的参数等等；
- 本地方法栈引用对象：
- 方法区中静态属性引用的对象：
- 方法区中常量引用的对象
- 所有被同步所synchronized持有的对象
- Java虚拟机内部的引用
- 反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等；
- 根据用户所选的垃圾收集器以及当前回收的区域不同，还可以有其他对象临时性的加入到GC Roots，比如分代收集和局部回收；

### 3. 对象的finalization机制

### 4. MAT与Profiler的GCRoots溯源

## 15.2 清除阶段

### 1. 标记-清除算法

### 2. 复制算法

### 3. 标记-压缩算法

### 4. 分代收集算法

### 5. 增量收集算法

### 6. 分区算法







# 第十六章 垃圾回收相关概念

# 第十七章 垃圾回收器



# 第一章 JVM概述

1. 什么是JVM：Java Virtual Machine，是java程序（二进制class字节码）的运行环境
   - Java代码一次编写，到处运行的基础
   - 自动内存管理，垃圾回收机制
2. JVM、JRE、JDK
   - JDK是运行环境
   - JDK + 基础类库 = JRE
   - JRE + 编译工具 = JDK（JavaSE程序、JavaEE程序）
3. JVM作用
   - 面试
   - 理解Java程序的底层实现原理
   - 中高级Java程序员的基础功力
   - 线上调优无从下手
   - 面试问题无从答起
   - 对于Java技术的核心Java虚拟机了解甚少：侧重的关注了上层框架，没关注底层技术；
   - 计算机系统体系对开发人员越来越远，可以不通过底层技术使用高级语言就可以开发应用；
   - 如何让系统变的更快？
   - 如何避免系统出现故障？
4. JDK学习路径
   - JVM内存机制
   - JVM垃圾回收机制
   - Java字节码
   - Java类加载器
   - Java即时编译

# 第二章 JVM内存机制

1. 程序计数器：JVM将java代码编译为java字节码（JVM指令），解释器将JVM指令解释为机器指令，再将机器指令交给CPU；

   - 程序计数器就是机主下一条JVM指令的执行地址
   - 传给你洗计数器的读取速度在JVM中最快
   - 程序计数器线程私有：因为线程会进行切换，当线程重新切换回来后需要知道当前线程上次的执行地址，从而可以继续执行
   - 是唯一一个不会内存溢出的区域

2. 虚拟机栈：栈的数据结构特点是先进后出，虚拟机栈是线程运行所需要的内存空间，虚拟机栈中的元素称为栈帧：

   - 一个栈帧表示一个方法（保存着方法参数，局部变量，返回地址等等）所占内存，
   - 一个方法可以调用其他方法，被调用的方法会被加入到栈顶；
   - 每个线程只能有一个活动栈帧（对应着正在执行的方法）

   > 垃圾回收不会也不需要回收栈内存中的垃圾：方法调用后会自动释放方法内存
   >
   > -Xss size：为占内存指定大小，默认大小是1024kb，Windows被虚拟内存影响，栈内存越大，会影响线程数变小
   >
   > 方法内存的局部变量如果没有逃离方法的作用范围，就是线程安全的；如果局部变量是对象并且逃离的方法作用范围是线程不安全的
   >
   > 栈内存溢出：①栈帧过多导致占内存溢出（方法的递归调用）②栈帧过大也会导致栈内存溢出

   - 线程运行诊断：

     - top：查看进程占用CPU消耗情况：查询出进程编号

     - ps：命令查询线程对CPU的占用，可以得到搞CPU对应的线程ID（显示是十进制的需要转为为16进制）

       ```sh
       ps H -ef | grep 进程编号
       ```

     - 使用jdk提供的工具查看指定进程中线程运行，根据转换为16进制的线程编号找到对应的线程和对应的Java位置

       ```sh
       jstack 进程id
       ```

3. 本地方法栈：是指不是由Java代码编写的，在Java中是被native修饰的方法；

   - native方法主要是由C、C++编写进行调用操作系统底层的API
   - 本地方法栈：是由JVM调用本地方法时分配的内存空间

4. 堆：通过new关键字创建的对象会在堆内存中，

   - 堆内存是线程共享的：需要考虑线程安全问题

   - 堆内存的是会被垃圾回收机制管理

   - Xmx：设置堆空间大小的参数

   - 堆内存诊断工具

     1. jsp工具：查看当前堆中有哪些java进程

     2. jmap：查看某一进程堆内存占用情况，只能查看某一时间的状况

        ```sh
        jmap -heap 进程id
        ```

     3. jconsole：图形界面的，多功能的检测，可以连续检测

     4. jvisualvm：图形界面工具

5. 方法区：

   - 是JVM所有线程共享的区域；存储类相关的信息：成员变量，构造方法，成员方法等信息
   - 是在虚拟机启动时被创建
   - 方法区是一个规范：在不同的虚拟机版本有不同的实现，在JVM6之前方法区定义在永久代中，在JVM8方法区是由元空间实现，元空间引用的是本地内存
   - 方法区设置参数：-XX:MaxMetaspaceSize=8m

6. 方法区-常量池：二进制自己吗的组成①类的基本信息②常量池③类方法定义

   - java反编译工具查看字节码文件

     ```sj
     javap -c class字节码
     ```

   - 常量池是为方法区中的局面指令提供参数的内存地址;

   - 运行时常量池：当类被加载后，就会被放入运行时常量池，在运行时常量池中jvm指令的地址编号就会被替换为真实的地址

   - StringTable：常量池中字符串池

     - 常量池中的字符串仅是符号，第一次用到时候才会变为对象
     - 利用串池机制，来避免重复创建字符串对象
     - 字符拼接原理是StringBuilder
     - string.intern()：尝试将字符串放入字符串常量池

7. [P3737_StringTable_垃圾回收](https://www.bilibili.com/video/BV1yE411Z7AP?p=37)



