# 前言



# 第一部分 集合



# 第二部分 线性结构



# 第三部分 树

## :anchor: 二叉树



## :anchor: 多叉树

### 2-3 树

:dash: **<font size=4 color=blue>定义与特征</font>**

- **2-3树中包含两种节点**：具有两个孩子的节点称它为2节点，具有三个孩子的节点称它为3节点；
  - **2节点：**只能包含两个孩子或没有孩子，不能出现有一个孩子的情况
  - **3节点：**只能包含三个孩子或没有孩子，不能出现有一个孩子或有两个孩子的情况
- **2-3树也是一种平衡搜索树**：
  - **2节点：**左子树包含的元素小于该元素，右子树包含的元素大于该元素。
  - **3节点：**左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。

:dash: **<font size=4 color=blue>原理</font>**

- 插入数据：要先查找一次，找出当前数据应该插入节点的位置；
  1. **对于空树：**插入一个2节点即可
  2. **对于2节点：**那么就把这个2节点变成一个3节点；
  3. **对于3节点：**
     - 如果只有一个3节点：将这个3节点分裂为三个二节点；
     - 向一个父节点为2节点的3节点中插入数据：构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。将2节点变为3节点，此时就有3个子节点了，这个3节点会分裂为2个2节点。
     - 向一个父节点为3节点的3节点中插入数据：构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。就这样一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3结点，或者是到达3结点的根。
     - 父节点到根节点均是3节点：意味着当前我们的树结构已经不满足当前节点增加的需要了，所有3节点拆分，树的深度增加一层。

### 2-3-4树

:dash: **<font size=4 color=blue>定义与特征</font>**

- 2-3-4树是对2-3树的概念扩展，包括了4节点的使用。

  - 一个4节点中包含小中大三个元素和四个孩子(要么有四个孩子要么没有，不存在其他情况)

- 如果某个4节点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。

  <img src='./imgs/树_2-3-4树' width=70%/>

### B树

:dash: **<font size=4 color=blue>定义与特征</font>**

- B树属于多叉树又名平衡多路查找树：2-3树和2-3-4树都是B树的特例
- **B 树的阶(M) ：**B树中所有节点的孩子节点数中的最大值称为B树的阶
  - 树中的每个节点至多有M棵子树
- 若根节点不是终端节点，则至少有两棵子树
- 除根节点和叶节点外，所有点至少有m/2棵子树（上溢）
- 所有叶子节点都在同一层 。

### B+树

:dash: **<font size=4 color=blue>定义与特征</font>**

- B+树是B树的变体，也是一种多路搜索树，其定义基本与B树相同，除了：
  1. 非叶子结点的子树指针与关键字个数相同；
  2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
  3. 为所有叶子结点增加一个链指针；
  4. 所有关键字都在叶子结点出现。

# 第四部分 图







# 第二章 线性结构

# 数据结构类型

## 1.1 数组

### :one: 一维数组

1. Java中数组

   - 数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起；
   - 数组名称是定义在栈空间中，数组初始化在堆空间中，元素之间的内存是连续的，可以通过索引获取任意位置的为唯一记录，数组名是堆空间的引用；
   - 数组本身属于引用数据类型:同一块堆内存空间可以被不同的栈内存所指向。

2. 数组的定义

   ```java
   // 声明并开辟数组
   数据类型[] 数组名称 = new 数据类型[长度];
   
   // 声明并初始化
   数据类型[] 数组名称 = new 数组类型[]{元素1,元素2 ... 元素n};
   
   // 声明并初始化
   数据类型[] 数组名称 = {元素1,元素2 ... 元素n};
   ```

### :two: 二维数组

1. 二维数组

   - 二维数组本质上指的是行列集合，也如果要确定某一个数据需要行索引和列索引来进行定位。

2. 二维数组的定义

   ```java
   // 数组的动态初始化
   数据类型 对象数组[][] = new 数据类型[行个数][列个数];
   
   // 数组的静态初始化
   数据类型 对象数组[][] = new 数据类型[行个数][列个数]{{值, 值,…}, {值, 值,…},…};
   ```

### :three: 稀疏数组

1. 稀疏数组

   - 稀疏数组是特殊的二维数组，主要作用是压缩二维数组；
   - 如果二维数组中有大量的重复元素，会造成空间浪费，不影响数组中原 有的元素值，我们采用了一种压缩的方式来 表示稀疏数组的内容。 

2. 稀疏数组的特点

   - 稀疏数组第一行表示数组的元信息

     > 第一个值表示二维数组的行
     >
     > 第二个值表示二维数组的列
     >
     > 第三个值表示二维数组中有效值的个数

   - 数组是个特殊的二维数组:行数是正常二维数组中有效值的元素的个数,3列

     > 第一列表示元素所在的行
     >
     > 第二列表示元素所在的列
     >
     > 第三列表示元素所对应的值

3. 二维数组与稀疏数组相互转换

   ```java
   /**
     * 二维数组 -> 稀疏数组
     *
     * @param arr 二维数组
     * @return 稀疏数组
     */
   public static int[][] arrayToSparse(int[][] arr) {
       int count = 0;
       for (int i = 0; i < arr.length; i++) {
           for (int j = 0; j < arr[0].length; j++) {
               if (arr[i][j] != 0) {
                   count++;
               }
           }
       }
       int sparse[][] = new int[count + 1][3];
       sparse[0][0] = arr.length;
       sparse[0][1] = arr[0].length;
       sparse[0][2] = count;
       int row = 1;
       for (int a = 0; a < arr.length; a++) {
           for (int b = 0; b < arr[0].length; b++) {
               if (arr[a][b] != 0) {
                   sparse[row][0] = a;
                   sparse[row][1] = b;
                   sparse[row][2] = arr[a][b];
                   row++;
               }
           }
       }
       return sparse;
   }
   ```

   ```java
   /**
     * 稀疏数组 -> 二维数组
     *
     * @param arr 稀疏数组
     * @return 二维数组
     */
   public static int[][] sparseToArray(int arr[][]) {
       int result[][] = new int[arr[0][0]][arr[0][1]];
       for (int i = 1; i < arr.length; i++) {
           for (int j = 0; j < arr[0].length; j++) {
               result[arr[i][0]][arr[i][1]] = arr[i][2];
           }
       }
       return result;
   }
   ```

### :four: 多维数组

## 1.2 栈

## 1.3 队列

## 1.4 链表

单向链表

双向链表

循环链表

静态链表

## 1.5 树

树

1. 树结点：包含一个数据元素及若干指向子树的分支；
2. 孩子结点：结点的子树的根称为该结点的孩子；
3. 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；
4. 兄弟结点：同一双亲的孩子结点；
5. 堂兄结点：同一层上结点；
6. 结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；
7. 树的高（深）度：树中最大的结点层
8. 结点的度：结点子树的个数
9. 树的度： 树中最大的结点度。
10. 叶子结点：也叫终端结点，是度为0的结点；
11. 分枝结点：度不为0的结点（非终端结点）；
12. 森林：互不相交的树集合；
13. 有序树：子树有序的树，如：家族树；
14. 无序树：不考虑子树的顺序；

二叉树

​	完全二叉树

​	满二叉树

​	二叉搜索树

​	平衡二叉树  红黑树

​	堆树

B树

B+树

B*树

哈夫曼树

字典树

后缀树

后缀数组

伸展树

线段树

树状数组

## 1.6 散列表

## 1.7 堆

## 1.8 图



# 前言

## 1.1 数据结构作用

- 数据结构研究的是数据如何在计算机中进行组织和存储, 使得我们可以高效的获取或修改数据
- 源码 : ~/liuyubobobo/Play-with-Data-Structures

## 1.2 数据结构的分类

### 1. 线性结构

- 数组
- 栈
- 队列
- 链表
- 哈希表

### 2. 树结构

- 二叉树
- 二分搜索树
- AVL
- 红黑树
- Treap
- Spaly
- 堆
- Trie
- 线段树
- K-D树
- 并查集
- 哈夫曼树

### 3. 图

- 邻接矩阵
- 邻接表

