# 第七章 Redis持久化选择

## 7.1 Redis持久化

1. Redis持久化介绍

    - Redis是内存中的数据结构存储系统，Redis的持久化是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。

2. 持久化方式

    - 方式一： 快照 - 完整的保存某一时刻的全部数据；
    - 方式二：操作日志 - 记录对数据的完整操作，从而根据对数据的操作过程重复实现数据完整性。

3. Redis持久化方式

    > Redis在运行时根据命令将数据持久化的指定文件中，在Redis启动时加载持久化文件将数据再写会到内存中。

    - RDB - 快照的方式
    - AOP - 操作日志方式

## 7.2 RDB持久化

1. Redis持久化RDB触发机制

    - 方式一： 命令 save - 同步的方式立即执行数据持久化操作，阻塞掉当前线程，会产生一个新的RDB文件，如果文件系统中有存在的RDB文件，则会覆盖旧文件。

    - 方式二：命令bgsave - 异步的方式，另起一个子线程执行数据持久化操作，会产生一个临时文件，待持久化结束后将旧文件替换为临时文件。

    - 方式三：配置文件 - 符合条件下则会触发持久化操作，后台默认采用同步方式完成。

        ```sh
        save 间隔的秒 操作数
        save 900 	1
        save 300 	10
        save 10 	10000
        ```

        > 不建议使用自动触发完成数据持久化
        >
        > - 全量复制 : 主从复制
        > - debug reload : debug级别的重启会触发Redis的RDB生成
        > - shutdown : 关闭Redis时候回触发持久化

2. Redis持久化相关配置

    ```sh
    # 不建议使用
    save 900 1
    save 300 10
    save 60 10000
    
    dir ./								# 持久化文件保存路径
    dbfilename dump-${port}.rdb			# 持久化文件名称
    stop-writes-on-bgsave-error yes		# 当save发生异常是否停止写入,建议开启
    rdbcompression yes					# 是否开启RDB文件压缩,建议开启
    rdbchecksum yes						# 是否开启REB校验
    ```

## 7.3 AOF持久化

1. 简介

    ​		AOF可以将Redis执行的每一条写命令追加到磁盘文件(appendonly.aof)中,在redis启动时候优先选择从AOF文件恢复数据。由于每一次的写操作，redis都会记录到文件中，所以开启AOF持久化会对性能有一定的影响，但是大部分情况下这个影响是可以接受的，我们可以使用读写速率高的硬盘提高AOF性能。与RDB持久化相比，AOF持久化数据丢失更少，其消耗内存更少(RDB方式执行bgsve会有内存拷贝)。

2. 开启AOF :默认是关闭的

    - 命令行方式开启

        ```sh
        config get appendonly
        
        config set appendonly yes
        
        config rewrite
        ```

    - 配置文件

        ```properties
        # 开启AOF
        appendonly yes
        
        # 修改AOP持久化文件名称
        appendfilename "appendonly-6379.aof"
        ```

3. 持久化过程

    - **追加写入**:redis将命令添加至缓冲区aof_buf,在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I/O次数，提高性能。

    - **同步命令到硬盘** :当写命令写入aof_buf缓冲区后，redis会将缓冲区的命令写入到文件

        > 同步策略:
        >
        > - no：不使用fsync方法同步
        > - always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件
        > - everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘

    - 文件重写(bgrewriteaof):AOF文件会越来越大,当然redis也对AOF文件进行了优化

        > 重写方式:
        >
        > - 重复或无效的命令不写入文件
        > - 过期的数据不再写入文件
        > - 多条命令合并写入

4. 重写触发条件

    - 手动触发:命令 行执行命令

        ```sh
        bgrewriteaof
        ```

    - 自动触发:根据配置文件

        - auto-aof-rewrite-min-size

            >  AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。

        - auto-aof-rewrite-percentage

            > 当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写

5. AOF消息头说明

    ```txt
    (+) 表示一个正确的状态信息，具体信息是当前行+后面的字符。
    
    (-)  表示一个错误信息，具体信息是当前行－后面的字符。
    
    (*) 表示消息体总共有多少行，不包括当前行,*后面是具体的行数。
    
    ($) 表示下一行数据长度，不包括换行符长度\r\n,$后面则是对应的长度的数据。
    
    (:) 表示返回一个数值，：后面是相应的数字节符。
    ```

6. AOF 相关配置参数

    ```sh
    auto-aof-rewrite-min-size 64mb
    #AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。
    
    auto-aof-rewrite-percentage  100
    #当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。
    
    appendfsync everysec
    #no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲。这种情况下，缓冲区数据同步不可控，并且在大量的写操作下，aof_buf缓冲区会堆积会越来越严重，一旦redis出现故障，数据
    #always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件。这种情况下由于每次写命令都写到了文件中, 虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。
    #everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，兼顾性能和数据安全，所以redis默认推荐使用该配置。
    
    aof-load-truncated yes
    #当redis突然运行崩溃时，会出现aof文件被截断的情况，Redis可以在发生这种情况时退出并加载错误，以下选项控制此行为。
    #如果aof-load-truncated设置为yes，则加载截断的AOF文件，Redis服务器启动发出日志以通知用户该事件。
    #如果该选项设置为no，则服务将中止并显示错误并停止启动。当该选项设置为no时，用户需要在重启之前使用“redis-check-aof”实用程序修复AOF文件在进行启动。
    
    appendonly no 
    #yes开启AOF，no关闭AOF
    
    appendfilename appendonly.aof
    #指定AOF文件名，4.0无法通过config set 设置，只能通过修改配置文件设置。
    
    dir /etc/redis
    #RDB文件和AOF文件存放目录
    ```

## 7.3 混合持久化

1. 简介

    ​		redis4.0添加了新的混合持久化方式，混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合 rdb 和 aof 的优点, 快速加载同时避免丢失过多的数据，缺点是 aof 里面的 rdb 部分就是压缩格式不再是 aof 格式，可读性差。

2. 开启混合持久化

    ```sh
    aof-use-rdb-preamble yes 则表示开启| no表示禁用 # 默认是禁用的，可通过config set修改。
    ```

    > ​		混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。
    >
    > ​		简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据

## 7.4 优缺点

### :anchor: RDB

- 优点：
    1. RDB 是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。 
    2. RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 `fork` 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
    3. RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

- 缺点：
    1. RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。
    2. 当redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。
    3. RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。

### :anchor: AOF　

- 优点：
    1. 数据更完整，秒级数据丢失(取决于设置fsync策略)。
    2. 兼容性较高，由于是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。

- 缺点：
    1. 数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。
    2. 相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。
    3. 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。

### :anchor: 混合持久化

- 优点：
    1. 混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。

- 缺点：
    1. 兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差