# 内容简介

    MySQL的学习是一个长期的持续学习的过程，工作经验也是一个积累的过程；正如本书分的三大部分：第一部分是MySQL基础，这部分主要是对1~4年的开发人员，这个阶段主要是在业务开发过程中涉及到的数据表的创建、字段的修改、索引的创建、会合理的使用数据类型和运算符进行数据查询、会根据业务需求编写出符合业务的SQL语句；随着工作经验的积累，过几年后可能会涉及到部分管理工作，此时需要能够掌握第二部分的内容：MySQL进阶，在这个阶段可能会涉及到数据表的权限管理、定位MySQL时候需要使用到的日志查询、随着业务中数据量的增加会有MySQL集群相关的要求或者读写分离；这个阶段需要不断打磨在第一阶段所掌握的MySQL知识，通过第二部分的学习能够开阔对MySQL的认识，为MySQL最重要最核心的技能做准备：MySQL调优，在这个阶段就需要对MySQL进行更深一步的学习，比如熟悉MySQL架构，了解MySQL索引原理，能够快速定位MySQL出现的问题并进行针对性的调优（包括但不限于SQL调优、索引调优、配置调优等等）；

# 第一部分 MySQL基础

## 第一章 数据库与MySQL

### 1.1 数据库

#### 1. 数据库概述

    首先根据行业中对数据库的要求可以对数据库做出两带你基本的定义：①数据库是存放具有一定规则数据的仓库、②数据库是一种数据结构,一种可以按一定格式存储大量数据,并且提供高效检索方式的一种数据结构；很好理解，只存储数据但是没有办法检索或者可以高效检索但是无法存储数据，这都不符合数据库的基本功能；

    数据库根据可以存储的数据格式和数据之间的关联关系，把数据库主要分为两大类：关系型数据库和非关系型数据库，比如MySQL、Oracle就属于关系型数据库，其主要特点是关系型数据库中主要是由固定模式的数据表组成的。

**★ 关系型数据库特性 : ACID**

- 原子性（Atomicity）
  
  > 指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

- 一致性（Consistency）
  
  > 事务前后数据的完整性必须保持一致。

- 隔离性（Isolation）
  
  > 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

- 持久性（Durability）
  
  > 指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

#### 2. 数据表概述

    在关系型数据库中，数据表是是一系列二维数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成，行被称为记录，是组织数据的单位；列被称为字段，每个列表示行中记录的一个属性，没一列都有响应的数据类型，数据宽度等信息；

    其中列的数据类型决定数据在计算机中的存储格式，代表不同的信息类型；常用的数据类型有：整数、浮点数、精确小数、日期/时间、字符串；

    关系型数据库的几个基本概念：

| 概念  | 解释                     |
| --- | ---------------------- |
| 行   | 也称为元组、记录；不允许两行中数据的元素重复 |
| 列   | 也称为字段、属性；列名不能重复        |
| 关键字 | 也称为主键；唯一的表示了表中的某一行     |
| 外键  | 其他表的关键字，表语表之间的关联关系     |

#### 3. 三大范式

    ★ 根据数据表行和列的关系，行与行之间的关系，为了能都快速的将数据存储到数据库并且可以快速的将所需要的数据检索出来，为了减少数据冗余、避免操作异常，在设计数据库时必须遵循的一定的规则，这种规则称为范式，关系型数据表设计需要遵循三大基本范式：

- 第一范式：是指数据表中所有的字段都是不可分割的数据项，一个列只能表达一个属性，一个列不能包含多个含义；

- 第二范式：数据表满足第一范式，并且没一行都有唯一标识，称为主键，即每一列都依赖主键；

- 第三范式：满足第一范式，并且没一列都和数据主键直接依赖，非主键字段不存在函数依赖关系，即满足第三范式；

### 1.2 数据库组成

#### 1. 数据库系统

- **数据库**：用于存储数据的地方，本质就是磁盘中的具有特殊格式的文件；

- **数据库管理系统**：用于管理数据库的软件（DataBase Management System），是用户创建、管理和维护数据库时所使用的软件，DBMS能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性和可靠性；

- **数据库应用程序**：为了提高数据库系统的处理English所使用的的管理数据库的应用程序；数据库应用程序负责和DBMS进行通信访问和管理DBMS中存储的数据，允许用户增加、修改、删除DB中的数据；

#### 2. SQL语言

    对数据库进行查询和修改操作的语言称为SQL，是指结构化查询语言（Structured Query Language）；SQL优多种不同的类型，主要包含四个部分

- 数据库定义语言（DDL）：DROP、CREAGE、ALTER等语句

- 数据库操作语言（DML）：INSERT、UPDATE、DELTE语句

- 数据库查询语言（DQL）：SELECT语句

- 数据库控制语言（DML）：GRANT、REVOKE、COMMIT、ROLLBACK等语句

### 1.3 MySQL概述

#### 1. 介绍

    MySQL是一个小型关系型数据库管理系统，与其他大型数据库管理系统（如Oracle、DB2、SQL Server）相比，MySQL规模小、体积小、速度快、成本低，并且对稍微复杂的应用提供满足要求的功能；MySQL的发展历程：

- **MySQL的历史最早可以追溯到1979年**：Monty Widenius,为一个叫TcX的小公司打工，并用BASIC设计了一个报表工具，过了不久，又将此工具，使用C语言重写，移植到Unix平台，当时，它只是一个很底层的面向报表的存储引擎。这个工具叫做Unireg。

- **1985 年**：以David Axmark 为首的小伙伴成立了一家公司，这就是MySQL AB 的前身，在业务中需要一个数据库。他们希望能够使用开源的产品。但在当时并没有一个合适的选择，没办法，那就自己开发吧。

- **1990年**：TcX的customer 中开始有人要求要为它的API提供SQL支持，当时，有人想到了直接使用商用数据库算了，但是Monty觉得商用数据库的速度难令人满意。于是，他直接借助于mSQL的代码，将它集成到自己的存储引擎中。但不巧的是，效果并不太好。于是,Monty雄心大起，决心自己重写一个SQL支持。

- **1996年**：MySQL 1.0发布, 在小范围内使用。到了96年10月，MySQL 3.11.1发布了

- **1999-2000年**：有一家公司在瑞典成立了，叫MySQL AB，开发出了 Berkeley DB引擎, 因为BDB支持事务处理，所以，MySQL从此开始支持事务处理了。

- **2000 年**：MySQL 公布了自己的源代码，并采用GPL（GNU General Public License）许可协议，正式进入开源世界。

- **2000年4月**：MySQL对旧的存储引擎进行了整理，命名为MyISAM

- **2001年**：集成了MyISAM和InnoDB 存储引擎。MySQL与InnoDB的正式结合版本是4.0。

- **2004年10月**：发布了经典的4.1版本。 2005年10月，有发布了里程碑的一个版本，MySQL 5.0.  在5.0中加入了游标，存储过程，触发器，视图和事务的支持。在5.0 之后的版本里，MySQL明确地表现出迈向高性能数据库的发展步伐。

- **2008年1月16日**：MySQL被Sun公司收购

- **2009年04月20日**：Oracle收购Sun 公司，MySQL 转入Oracle 门下。

- **2010年04月22日**： 发布MySQL 5.5, MySQLcluster 7.1.

#### 2. MySQL特点

- **功能强大**：MySQL中提供了多种数据库存储引擎，各个引擎各有所长，适用于不同的应用场合。用户可以选择最合适的引擎以得到最高性能，这些引擎升值可以应用处理每天访问量数亿的高强度Web搜索站点。MySQL支持事务、视图、存储过程和触发器等。

- **支持跨平台**：MySQL支持至少20种以上的开发平台，包括Linux、Windows、FreeBSD、IBMAIX、AIX和FreeBSD等。这使得在任何平台下编写的程序都可以进行移植，而不需要对程序做任何修改。

- **运行速度快**：高速是MySQL的显著特性。在MySQL中，使用了极快的B书磁盘表（MyISAM）和索引压缩；通过使用优化的单扫描多连接，能够极快的实现连接；SQL函数使用高度优化的类库实现，运行速度极快。

- **支持面向对象**：PHP支持混合编程方式。编程方式可分为纯粹面向对象、纯粹面向过程、面向对象与面向过程混合3种方式。

- **安全性高**；灵活安全的权限和密码系统允许主机的基本验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证了密码的安全。

- **成本低**：MySQL数据库是一种完全免费的产品，用户可以直接从网上下载。

- **支持多种开发语言**：MySQL为各种流行的程序设计语言提供支持，为他们提供了很多的API函数。

- **数据库存储容量大**：MySQL数据库的最大有效容量通常是有操作系统对文件大小的限制决定的，而不是有MySQL内部限制决定的。InnDB存储引擎讲InnDB表保存在一个表空间内，该表空间可由数个文件创建，表空间的最大容量为64TB,可以轻松处理拥有上万条记录的大型数据库。

- **支持强大的内置函数**：提供了大量内置函数，几乎涵盖了Web应用开发中的所有功能。它内置了数据连接、文件上传等功能，MySQL支持大量的扩展库，如MySQL等，为快速开发Web应用提供方便

## 第二章 MySQL安装与配置

### 2.1 MySQL安装

#### 1. Windows系统

#### 2. Linux系统安装

#### 3. MacOS系统安装

#### 4. Docker File安装

#### 5. Docker Componse安装

### 2.2 MySQL配置

### 2.3 MySQL命令行工具

### 2.4 MySQL客户端工具

1. SQLyog：https://sqlyog.en.softonic.com/

2. Navicat：http://www.navicat.com.cn/

3. DataGrip：https://www.jetbrains.com/datagrip/

## 第三章 MySQL入门

### 3.1 连接MySQL

### 3.2 MySQL基本操作

### 3.3 MySQL存储引擎概述

## 第四章 数据表基本操作

### 4.1 字段约束

### 4.2 字段默认值

### 4.3 数据表操作

## 第五章 数据类型与运算符

## 第六章 MySQL内置函数

## 第七章 MySQL查询

1. 窗口函数
2. 公用表达式

## 第八章 索引

### 8.1 什么是索引

​		索引是帮助MySql高效获取数据的数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

​		对应MySQL：由于存储引擎表示的是数据在磁盘上面的不同的组织形式，所以索引底层采用哪种数据结构是跟数据库的存储引擎相关的。如果是MyIsam或者是InnoDB存储引擎，那么对应的底层的数据结构为B+树，如果是Memory存储引擎，那么对应的底层的数据结构为Hash表。采用B+树的最根本的原因是由于二叉树的树太高，树太高则直接影响到磁盘IO的次数，影响数据查询的效率，采用B+树的数据结构，可以在某个数据节点里面尽可能多的存储数据，使树的高度尽量的变低，提高效率。日常开发过程中，遇到的比较多的可能就是聚簇索引和联合索引，里面又涉及到了覆盖索引，最左匹配，回表，索引下推等各方面的知识点，在编写SQL语句的时候，我们就可以利用这些点来进行优化，提高数据的查询效率。

### 8.2 索引类型

1. 主键索引：primary key

   - create table语句中创建主键索引

     ```sql
     create table User
     (
         uid    int         not null,
         name   varchar(50) not null,
         gender tinyint     not null,
         primary key (`uid`)
     );
     ```

   - alter table语句操作主键索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

2. 唯一索引：unique

   - create table语句中创建唯一索引

     ```sql
     create table User
     (
         uid    int         not null,
         name   varchar(50) not null,
         gender tinyint     not null,
         unique key u_name(`name`)
     );
     ```

   - alter table语句操作唯一索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

3. 单列索引：index

   - create table语句中创建单列索引

     ```sql
     create table User
     (
         uid    int         not null,
         name   varchar(50) not null,
         gender tinyint     not null,
         key idx_name (`name`)
     );
     ```

   - alter table语句操作单列索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

4. 联合索引：index

   - create table语句中创建联合索引

     ```sql
     create table User
     (
         uid    int         not null,
         name   varchar(50) not null,
         gender tinyint     not null,
         key idx_name_gender (`name`, `gender`)
     );
     ```

   - alter table语句操作单列索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

5. 外键索引：foreign key

   - create table语句中创建外键索引

     ```sql
     
     ```

   - alter table语句操作外键索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

6. 全文索引：fulltext 

   - create table语句中创建全文索引

     ```sql
     create table User
     (
         uid    int         not null,
         name   varchar(50) not null,
         gender tinyint     not null,
         fulltext key ft_name (`name`)
     );
     ```

   - alter table语句操作全文索引

     ```sql
     -- 添加索引
     
     -- 删除索引
     
     ```

### 8.3 索引形态

1. 聚簇索引：
2. 非聚簇索引：

### 8.4 索引相关术语

1. 最左前缀原则
2. 覆盖索引
3. 回表
4. 索引下推

### 8.5 索引结构

1. Hash索引
2. Fulltext全文索引
3. B+Tree索引

## 第九章 存储过程和函数

## 第十章 视图

## 第十一章 触发器

# 第二部分 SQL进阶

## 第一章 MySQL用户管理

## 第二章 数据备份与恢复

## 第三章 MySQL日志

- 参考资料
  - [(30条消息) 一文带你看懂 InnoDB 中的 MVCC、Undo、Redo 机制_扛麻袋的少年的博客-CSDN博客_innodb redo undo](https://blog.csdn.net/lzb348110175/article/details/106788351)
  - 

## 第四章 MySQL集群

## 第五章 MySQL读写分离

# 第三部分 MySQL调优

## 第一章 MySQL架构

### 1.1 MySql体系

![img](./resource/mysql_架构.png)

MySQL的架构自顶向下大致可以分为网络连接层、数据库服务层、存储引擎层和系统文件层四大部分。

1. 网络连接层：网络连接层位于整个MySQL体系架构的最上层，主要担任客户端连接器的角色。提供与MySQL服务器建立连接的能力，几乎支持所有主流的服务端语言，例如：Java、C、C++、Python等，各语言都是通过各自的API接口与MySQL建立连接。

2. 数据库服务层：数据库服务层是整个数据库服务器的核心，主要包括了系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存等部分。

   - 连接池：主要负责存储和管理客户端与数据库的连接信息，连接池里的一个线程负责管理一个客户端到数据库的连接信息。
   - 系统管理和控制工具：提供数据库系统的管理和控制功能，例如对数据库中的数据进行备份和恢复，保证整个数据库的安全性，提供安全管理，对整个数据库的集群进行协调和管理等。
   - SQL接口：主要负责接收客户端发送过来的各种SQL命令，并将SQL命令发送到其他部分，并接收其他部分返回的结果数据，将结果数据返回给客户端。
   - 解析树：主要负责对请求的SQL解析成一棵“解析树”，然后根据MySQL中的一些规则对“解析树”做进一步的语法验证，确认其是否合法。
   - 查询优化器：在MySQL中，如果“解析树”通过了解析器的语法检查，此时就会由优化器将其转化为执行计划，然后与存储引擎进行交互，通过存储引擎与底层的数据文件进行交互
   - 缓存：MySQL的缓存是由一系列的小缓存组成的。例如：MySQL的表缓存，记录缓存，MySQL中的权限缓存，引擎缓存等。MySQL中的缓存能够提高数据的查询性能，如果查询的结果能够命中缓存，则MySQL会直接返回缓存中的结果信息。

3. 存储引擎层：MySQL中的存储引擎层主要负责数据的写入和读取，与底层的文件进行交互。值得一提的是，MySQL中的存储引擎是插件式的，服务器中的查询执行引擎通过相关的接口与存储引擎进行通信，同时，接口屏蔽了不同存储引擎之间的差异。MySQL中，最常用的存储引擎就是InnoDB和MyISAM。

4. 系统文件层：系统文件层主要包括MySQL中存储数据的底层文件，与上层的存储引擎进行交互，是文件的物理存储层。其存储的文件主要有：日志文件、数据文件、配置文件、MySQL的进行pid文件和socket文件等。

   - 日志文件：MySQL中的日志主要包括：错误日志、通用查询日志、二进制日志、慢查询日志等

     > - 错误日志：主要存储的是MySQL运行过程中产生的错误信息。可以使用下面的SQL语句来查看MySQL中的错误日志。
     >
     >   ```sql
     >   show variables like '%log_error%';
     >   ```
     >
     > - 通用查询日志：主要记录MySQL运行过程中的一般查询信息，可以使用下面的SQL语句来查看MySQL中的通用查询日志文件。
     >
     >   ```sql
     >   show variables like '%general%';
     >   ```
     >
     > - 二进制日志：主要记录对MySQL数据库执行的插入、修改和删除操作，并且也会记录SQL语句执行的时间、执行的时长，但是二进制日志不记录select、show等不修改数据库的SQL。主要用于恢复数据库的数据和实现MySQL主从复制。
     >
     >   ```sql
     >   -- 查看二进制日志是否开启
     >   show variables like '%log_bin%';
     >   -- 查看二进制日志的参数
     >   show variables like '%binlog%'
     >   -- 查看日志文件
     >   show binary logs;
     >   -- 慢查询日志：查看是否开启慢查询日志
     >   show variables like '%slow_query%';
     >   -- 慢查询日志：查看慢查询设置的时长
     >   show variables like '%long_query_time%'
     >   ```

   - 数据文件：数据文件中主要包括了：db.opt文件、frm文件、MYD文件、MYI文件、ibd文件、ibdata文件、ibdata1文件、ib_logfile0和ib_logfile1文件等。

     > - db.opt文件：主要记录当前数据库使用的字符集和检验规则等信息。
     > - frm文件：存储数据表的结构信息，主要是数据表相关的元数据信息，包括数据表的表结构定义信息，每张表都会有一个frm文件。值得注意的是：MySQL8版本中的innodb存储引擎的表没有frm文件。（MySQL8新特性，从使用到底层原理与MySQL5有不同）
     > - MYD文件：MyISAM存储引擎专用的文件格式，主要存放MyISAM存储引擎数据表中的数据，每张MyISAM存储引擎表对应一个.MYD文件。
     > - MYI文件：MyISAM存储引擎专用的文件格式，主要存放与MyISAM存储引擎数据表相关的索引信息，每张MyISAM存储引擎表对应一个.MYI文件。
     > - ibd文件：存放Innodb存储引擎的数据文件和索引文件，主要存放的是独享表空间的数据和索引，每张表对应一个.ibd文件。
     > - ibdata文件：存放Innodb存储引擎的数据文件和索引文件，主要存放的是共享表空间的数据和索引，所有表共用一个（或者多个）.ibdata文件，可以根据配置来指定共用的.ibdata文件个数。
     > - ibdata1文件：MySQL的系统表空间数据文件，主要存储MySQL的数据表元数据、Undo日志等信息。
     > - ib_logfile0和ib_logfile1文件：
     > - MySQL数据库中的Redo log文件，主要用于MySQL实现事务的持久性。如果在某个时间点MySQL发生了故障，此时如果有脏页没有写入到数据库的ibd文件中，在重启MySQL的时候，MySQL会根据Redo Log信息进行重做，将写入Redo Log并且尚未写入数据表的数据进行持久化操作。

   - 配置文件：用于存在MySQL所有的配置信息，在Unix/Linux环境中是my,cnf文件，在Windows环境中是my.ini文件。

   - pid文件：pid文件是存放MySQL进程运行时的进程号的文件，主要存在于Unix/Linux环境中，具体的存储目录可以在my.cnf或者my.ini文件中进行配置。

   - socket文件：socket文件和pid文件一样，都是MySQL在Unix/Linux环境中运行才会有的文件。在Unix/Linux环境中，客户端可以直接通过socket来连接MySQL。

### 1.2 MySQL事务原理

1. 事务操作：了解MySQL的架构体系后，对MySQL的事务操作：其中start transaction标识事务开始，commit提交事务，将执行结果写入到数据库。如果sql语句执行出现问题，会调用rollback，回滚所有已经执行成功的sql语句。当然，也可以在事务中直接使用rollback语句进行回滚。

   ```sql
   start transaction;
   ……  #一条或多条sql语句
   commit;
   ```

2. 自动提交：MySQL中默认采用的是自动提交（autocommit）模式，在自动提交模式下，如果没有start transaction显式地开始一个事务，那么每个sql语句都会被当做一个事务执行提交操作。在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。不过，常用的select、insert、update和delete命令，都不会强制提交事务。

   ```sql
   -- 查看提交模式
   show variables like 'autocommit';
   -- 关闭自动提交模式：autocommit参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。
   set autocommit =0;
   ```

3. MySQL事务特点

   - 原子性(Atomicity)：是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；

     > 原理：InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。逻辑日志和物理日志的区别 看记日志的时候 是针对一行记录，就是逻辑日志 如果是一个数据页，就是物理日志
     >
     > > 以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。
     > >
     > > ![image-20220731130003694](.\resource\image-20220731130003694.png)
     > >
     > > 从上图可以了解到数据的变更都伴随着回滚日志的产生：①产生了被修改前数据(zhangsan,1000) 的回滚日志②产生了被修改前数据(zhangsan,0) 的回滚日志
     >
     > - 结论：①每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上②所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。 回滚过程如图
     >
     >   ```sql
     >   当delete一条记录时，undo log中会记录一条对应的insert记录 
     >   当insert一条记录时，undo log中会记录一条对应的delete记录
     >   当update一条记录时，它记录一条对应相反的update记录
     >   ```

   - 持久性(Durability)：事务一旦提交，其所做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。

     > 原理：先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。
     >
     > 为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用： 读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取再放入缓冲池；
     >
     > 写数据：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中（这一过程称为刷脏）；
     >
     > 上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！
     >
     > 因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。
     >
     > 于是 redo log就派上用场了。下面看下redo log是什么时候产生的
     >
     > ![image-20220731130335776](E:\AdminCode\NoteStudy\note_blogs_docsify\class03_数据库\part02_mysql\point01_mysql基础\resource\image-20220731130335776.png)
     >
     > 既然redo log也需要存储，也涉及磁盘IO为啥还用它？
     >
     > （1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。
     >
     > （2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。
     >
     > 「redo log与binlog」
     >
     > 我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：
     >
     > （1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。
     >
     > （2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。
     >
     > （3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。
     >
     > （4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：
     >
     > 前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。 除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。

   - 隔离性(Isolation)：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。

     > 原理：隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)，那么隔离性的探讨，主要可以分为两个方面：
     >
     > (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性 (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性；首先来看并发情况下，读操作可能存在的三类问题
     >
     > - 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。
     >
     >   | 时间 | 事务 A                             | 事务 B                           |
     >   | ---- | ---------------------------------- | -------------------------------- |
     >   | T1   | 开始事务                           | 开始事务                         |
     >   | T2   |                                    | 修改张三的余额<br /> - 100 > 200 |
     >   | T3   | 查询张三的余额<br /> - 200【脏读】 |                                  |
     >   | T4   |                                    | 提交事务                         |
     >
     > - 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。
     >
     >   | 时间 | 事务 A                                     | 事务 B                            |
     >   | ---- | ------------------------------------------ | --------------------------------- |
     >   | T1   | 开始事务                                   | 开始事务                          |
     >   | T2   | 查询张三的余额：<br /> - 100               |                                   |
     >   | T3   |                                            | 修改张三的余额：<br />- 100 > 200 |
     >   | T4   |                                            | 提交事务                          |
     >   | T5   | 查询张三的余额：<br /> - 200【不可重复读】 |                                   |
     >
     > - 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。
     >
     >   | 时间 | 事务 A                                                       | 事务 B                              |
     >   | ---- | ------------------------------------------------------------ | ----------------------------------- |
     >   | T1   | 开始事务                                                     | 开始事务                            |
     >   | T2   | 查询id in 0~5的余额：<br /> - id=1 & 张三=100                |                                     |
     >   | T3   |                                                              | 账户插入用户id=2<br /> - 李四 = 200 |
     >   | T4   |                                                              | 提交事务                            |
     >   | T5   | 查询id in 0~5的余额：【不可重复读】<br /> - 张三=100<br /> - 李四=200 |                                     |

   - 一致性：一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。

     > 可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。
     >
     > 实现一致性的措施包括：
     >
     > 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证
     >
     > 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
     >
     > 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致

### 1.3 MySQL事务隔离级别

1. 事务隔离级别

   | 事务的隔离级别            | 脏读 | 不可重复读 | 幻读 |
   | ------------------------- | ---- | ---------- | ---- |
   | 读未提交 READ UNCOMMITTED | √    | √          | √    |
   | 读已提交 READ COMMITTED   |      | √          | √    |
   | 可重复读 REPEATABLE READ  |      |            | √    |
   | 串行化 SERIALIZABLE       |      |            |      |

   > 在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是读已提交(如Oracle)或可重复读（后文简称RR）。 可以通过如下两个命令分别查看隔离级别：
   >
   > ```sql
   > select @@tx_isolation;
   > ```

2. MVCC：RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。下面的例子很好的体现了MVCC的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在T5时刻，事务A和事务C可以读取到不同版本的数据;

   | 时间 | 事务 A                         | 事务 B                             | 事务C                          |
   | ---- | ------------------------------ | ---------------------------------- | ------------------------------ |
   | T1   | 开始事务                       | 开始事务                           |                                |
   | T2   | 查询张三的余额：： <br />- 100 |                                    |                                |
   | T3   |                                | 修改张三的余额：<br /> - 100 > 200 |                                |
   | T4   |                                | 提交事务                           |                                |
   | T5   | 查询张三的余额：： <br />- 100 |                                    | 查询张三的余额：： <br />- 200 |

   > MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和undo log。其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等；当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log，从而实现MVCC；隐藏列的详细格式不再展开。
   >
   > 下面结合前文提到的几个问题分别说明 
   >
   > - 避免脏读：当事务A在T3时间节点读取zhangsan的余额时，会发现数据已被其他事务修改，且状态为未提交。此时事务A读取最新数据后，根据数据的undo log执行回滚操作，得到事务B修改前的数据，从而避免了脏读。
   >
   >   | 时间 | 事务 A                                 | 事务 B                           |
   >   | ---- | -------------------------------------- | -------------------------------- |
   >   | T1   | 开始事务                               | 开始事务                         |
   >   | T2   |                                        | 修改张三的余额 <br />- 100 > 200 |
   >   | T3   | 查询张三的余额 <br />- 100【避免脏读】 |                                  |
   >   | T4   |                                        | 提交事务                         |
   >
   > - 避免不可重复读：当事务A在T2节点第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1；当事务B提交时，该行记录的版本号增加，假设版本号为2；当事务A在T5再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。
   >
   >   | 时间 | 事务 A                                         | 事务 B                             |
   >   | ---- | ---------------------------------------------- | ---------------------------------- |
   >   | T1   | 开始事务                                       | 开始事务                           |
   >   | T2   | 查询张三的余额：<br /> - 100                   |                                    |
   >   | T3   |                                                | 修改张三的余额：<br /> - 100 > 200 |
   >   | T4   |                                                | 提交事务                           |
   >   | T5   | 查询张三的余额：<br /> - 100【避免不可重复读】 |                                    |
   >
   > - 避免幻读：nnoDB实现的RR通过next-key lock机制避免了幻读现象。next-key lock是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。当然，这里我们讨论的是不加锁读：此时的next-key lock并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等）；准确起见姑且称之为类next-key lock机制。还是以前面的例子来说明：当事务A在T2节点第一次读取0<id<5数据时，标记的不只是id=1的数据，而是将范围(0,5)进行了标记，这样当T5时刻再次读取0<id<5数据时，便可以发现id=2的数据比之前标记的版本号更高，此时再结合undo log执行回滚操作，避免了幻读。
   >
   >   | 时间 | 事务 A                                             | 事务 B                             |
   >   | ---- | -------------------------------------------------- | ---------------------------------- |
   >   | T1   | 开始事务                                           | 开始事务                           |
   >   | T2   | 查询id in 0~5的余额：<br /> - id=1 & 张三=100      |                                    |
   >   | T3   |                                                    | 账户插入用户id=2<br />- 李四 = 200 |
   >   | T4   |                                                    | 提交事务                           |
   >   | T5   | 查询id in 0~5的余额：<br /> - 张三=100【避免幻读】 |                                    |

## 第二章 MySQL引擎

- 参考资料
  - [Mysql第三章：存储引擎（MyISAM和Innodb）](https://blog.csdn.net/huyiju/article/details/80968962)
  - 

### 2.1 什么是存储引擎

MySQL中的数据用各种不同的技术存储在文件(或者内存)中。每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。例如，如果你在研究大量的临时数据，你也许需要使用内存MySQL存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。

这些不同的技术以及配套的相关功能在 MySQL中被称作存储引擎(也称作表类型)。 MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。

常用存储引擎：①InnoDB、②MyISAM

### 2.1 InnoDB

1. InnoDB存储引擎支持事务
2. InnoDB存储引擎支持行锁和表锁设计,同时支持外键
3. 自动增长列必须是索引，如果是组合索引，也必须是组合缩影的第一列
4. InnoDB存储引擎表单独存放到一个独立的ibd文件中
5. InnoDB通过使用多版本并发控制MVCC来获得高并发性

### 2.2 MyISAM

1. MyISAM存储引擎不支持事务
2. MyISAM存储引擎支持表锁设计,不支持行锁、外键
3. MyISAM存储引擎表由MYD和MYI两部分组成，其中MYD（MYData）用来存放数据文件,而MYI(MYIndex)则用来存放索引文件。另外 .frm存储表定义
4. 支持3种不同存储格式 A. 静态表，固定长度表，存储速度快，占用空间多，故障易回复 B.动态表，占用空间相对小，频繁更新，产生碎片多，故障恢复难 C.压缩表，占用空间小，每个记录被单独压缩

### 2.3 比较

1. MyISAM 和InnoDB 存储引擎默认BTREE索引，支持前缀索引，MyISAM 前缀长度为1000 字节，而InnoDB 前缀长度为767字节
2. InnoDB中至少有一个聚簇索引，可以有多个非聚簇索引，MyISAM中只有非聚簇索引

## 第四章 SQL调优

## 第五章 索引调优

## 第六章 MySQL经验技巧
