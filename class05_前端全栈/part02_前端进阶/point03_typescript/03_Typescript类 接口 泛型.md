# 第四章 Typescript的类

## 4.1 ES5的类定义

### 1. 类的定义

```js
function 首字母大写的方法名(){
    this.属性
    this.方法 = function(){
    	//TUDO
    }
}
```

### 2. 使用原型链对方法的扩展

```js
类名.prototype.属性 = 值;
类型.prototype.方法名 = function(){
    //TUDO
}
```

- 通过原型链定义的属性会被多个实例共享
- 构造函数中的属性不会被多个实例共享

### 3. 类的静态方法

```js
类名.静态方法名称 = function(){
    //TUDO
}
```

- 本质是动态的给类属性添加方法

### 4. ES5的继承

- 使用原型链继承

    ```js
    function 父类名称(){
        //TUDO
    }
    function 子类(){
        //TUDO
    }
    子类.prototype = new 父类();
    ```

    > - 原型链继承 : 可以继承构造方法的属性和方法, 也可以继承原型链上的属性和方法
    > - 原型链继承 : 实例化子类无法向父类传递参数

- 使用对象冒充实现继承

    ```js
    function 父类名称(){
        //TUDO
    }
    function 子类名称(){
        父类.call(this);
        //TUDO
    }
    ```

    > - 对象冒充可以继承狗仔函数里的属性和方法
    >     - 不可以继承原型链上的属性和方法

- 使用原型链和对象冒充组合方式实现继承

    ```js
    function 父类名称(){
        //TUDO
    }
    function 子类名称(){
    	父类.call(this);
        //TUDO
    }
    子类.prototype = new 父类();
    ```

## 4.2 Typescript的类

### 1. 定义类 : `class` + `constructor`

```js
class Persion{
    属性: 属性类型;
    constructor(构造参数:参数类型,构造参数n: 参数类型){
        this.属性 = 构造参数值;
    }
    方法名称(): 返回值类型{
        //TUDO
    }
}
```

> - Typescript中默认修饰符都为`public`
>
> - 构造函数 : 实例化对象时候回触发的构造方法`constructor`

### 2. 类的继承 : `extends` + `super`

- 继承的实现方式
    - 第一步 : 使用extends声明父类
    - 第二部 : 在子类构造方法中调用父类构造方法 : `super(父类构造参数)`

### 3. 类的修饰符 : 和Java相同

- **public**
- **protect**
- **private**

### 4. 类的静态成员

- 定义静态成员属性

    ```js
    class 类名{
        static 属性名: 属性类型
    }
    ```

- 定义静态方法

    ```js
    class 类名{
        static 方法名():返回值{
            // TUDO
        }
    }
    ```

### 5. 抽象类 多态

- 抽象类
    - 抽象类不能被实例化
    - 抽象方法必须定义在抽象类中

- 抽象方法没有方法体 : 只能被子类重写
- 多态 : 表示多个子类继承同一个父类, 子类覆盖父类方法, 子类执行父类方法有不同的表现形式

# 第五章 Typescript的接口

## 5.1 接口的概述

- 程序中的接口是一种规范的定义 : 用于规范指定类型的具体行为和规范
- 特定 : 只是规定类型的行为,而不关心类的内部数据状态与实现细节
- Typescript的接口包括 : 属性接口,函数接口, 可索引接口, 类类型接口

## 5.2 Typescript接口类型

### 1. 属性接口

- 规定方法参数 : 如果方法的参数是个对象,适应属性接口规定这个参数对象的属性

- 定义属性接口 : interface

    ```js
    // 定义属性接口
        interface 接口名称{
            属性名称: 属性类型
        }
    
    // 在方法参数中使用接口
    	function 方法名称(参数对象: 接口名称){
            // TUDO
        }
    ```

- 方法调用

    - 方式一 : 调用方法时传入json格式的 : json的key符合接口的属性名称与类型

        ```js
        方法名称({接口属性1:属性值,接口属性2:属性值, ... ..})
        ```

        > json数据中的属性数量和类型必须符合接口规范

    - 方式二 : 传入对象参数

        ```js
        // 定义对象
            let obj = {
                key1:val
                key2:val
            };
        // 传递参数对象
            方法名称(obj);
        ```

        > 对象中的属性必须符合包含属性接口中的属性

### 2. 可选属性接口 ?

- 定义接口的属性是可选的

### 3. 函数型接口

- 对方法 | 方法 的参数和返回类型进行规范的接口

- 定义函数型接口 

    ```js
    // 定义函数型接口
    	interface 接口名称{
            方法名称(参数名称: 参数类型): 返回值;
        }
    // 函数接口的使用
    	let 方法名: 接口类型 = function(参数名:参数类型): 返回值类型{
            // TUDO
        }
    ```

### 4. 可索引接口 

- 对数组 和 对象的规范

- 数组索引接口

    ```js
    // 定义数组索引接口
    	interface 接口名称{
            [index:number]:元素类型
        }
    // 数组使用索引接口
    	let 数组名: 数组接口名[] = []
    ```

    > 数组的索引是number类型的 , 数组元素的类型可以在接口中规范

- 对象索引接口

    ```js
    // 定义对象索引接口
    	interface 接口名称{
            [index:对象key的类型]: 对象value的类型
        }
    // 对象使用索引接口
    	let 对象名: 对象接口 = [];
    ```

### 5. 类类型接口 

- 给类定义接口 : 规范类型的属性和方法

- 定义和使用格式

    ```js
    // 定义接口
        interface 接口名称{
            属性: 属性类型
            方法名称(参数名称: 参数类型): 返回类型;
        }
    // 使用接口
    	class 类名 implements 接口名称{
        	属性: 属性类型;
    		方法名称(参数名: 参数类型):返回类型{
                // TUDO
            }
        }
    ```

### 6. 接口的继承

- 接口可以继承接口
- 一个类可以继承一个类 , 可以实现多个接口

# 第六章 Typescript的泛型

## 6.1 泛型的概述

- 泛型是指类型的参数化 : 在使用时候的具体类型由调用者指定
- 泛型的定义 规范泛型标识是定义在 一对尖括号中<T>

## 6.2 Typescript中的泛型

### 1. 泛型函数

- 在调用函数时候, 传入类型参数, 可以在方法参数和返回值使用泛型

    ```js
    function 方法名称<T> (参数名称:泛型T):泛型T{
        // TUDO
    }
    ```

- 调用方法

    ```js
    方法名称<string>(参数:string);
    ```

### 2. 泛型类

- 在实例化类的时候, 可以传递类型参数, 在类内部可以使用该类型

    ```js
    class 类名<T> {
        属性名称: 泛型T;
        add: (x: T, y: T) => T;
    }
    ```

### 3. 泛型接口

- 实例化类实现接口时, 通过向接口传递参数, 实现接口的复用

    ```js
    interface 接口名称 {
        <T>(arg: T): T;
    }
    
    interface 接口名称<T> {
        (arg: T): T;
    }
    ```

    